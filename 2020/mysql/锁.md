![title](https://raw.githubusercontent.com/liujinxi931204/image/master/gitnote/2020/06/17/1592384728792-1592384729092.png)  
# MySQL锁  
锁是计算机协调多个进程或线程并访问某一资源的机制  
## MySQL锁概述  
MyISAM和MEMORY存储引擎采用的是表级锁(table-level locking);BDB存储引擎采用的是页面锁(page-level locking),但也支持表级锁;InnoDB存储引擎默认采用的是行级锁(row-level locking)，也支持表级锁  
1. 表级锁：开销小，加锁快，不会出现死锁；锁定粒度大，发生锁冲突的概率最高，并发度最低  
2. 行级锁：开销大，加锁慢，会出现死锁；锁定粒度小，发生锁冲突的概率最低，并发度最高  
3. 页面锁：开销和加锁时间介于表锁和行锁之间；会出现死锁；锁定粒度介于表锁和行锁之间，并发度一般  
BDB已经被InnoDB所取代  
## MyISAM表锁  
MyISAM存储引擎只支持表锁，不支持行锁和事务  
### 查看表锁争用情况  
`show status like '%table_locks%';`  
![title](https://raw.githubusercontent.com/liujinxi931204/image/master/gitnote/2020/08/26/1598429010951-1598429011016.png)  
其中如果Table_locks_waited的值比较高，则说明存在着较严重的表级锁争用情况  
### MyISAM表级锁的锁模式  
MyISAM的表级锁有两种模式：表共享读锁(Table Read Lock)和表独占写锁(Table Write Lock)  
![title](https://raw.githubusercontent.com/liujinxi931204/image/master/gitnote/2020/08/26/1598429287349-1598429287351.png)  
可见，对MyISAM存储引擎的表进行读操作，不会阻塞其他用户对同一表的读操作，但是会阻塞对同一表的写操作；对MyISAM表的写操作，则会阻塞其他用户对同一表的读操作和写操作；MyISAM表的读操作与写操作之间是串行的  
### 如何加表锁
1. 默认  
MyISAM在执行查询语句(select)前会自动给涉及的表加读锁；在执行更新语句(udpate、insert、delete)前会自动给涉及的表加写锁  
2. 显式给MyISAM表加锁  
显式加读锁  
`lock table table_name read`  
显示加写锁  
`lock table table_name write`  
3. 释放锁  
`unlock tables`会释放所有的表上的锁  
`unlock table table_name`释放表名为table_name表上的锁  
在用lock table给表显式地加锁时，必须同时取得所有涉及到表的锁，并且MySQL不支持锁升级。也就是说，在执行lock tables后，只能访问显示加锁的这些表，不能访问未加锁的表；同时，如果加的是读锁，那么只能执行查询操作，不能执行更新操作  
正是因为MyISAM总一次获得SQL语句的所需要的全部锁，MyISAM表不会出现死锁的情况  
当使用`lock table table_name read`锁定MyISAM表时，不能查询被锁定表之外的表，也不能对锁定的表进行更新操作  







