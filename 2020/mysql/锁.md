![title](https://raw.githubusercontent.com/liujinxi931204/image/master/gitnote/2020/06/17/1592384728792-1592384729092.png)  
# MySQL锁  
锁是计算机协调多个进程或线程并访问某一资源的机制  
## MySQL锁概述  
MyISAM和MEMORY存储引擎采用的是表级锁(table-level locking);BDB存储引擎采用的是页面锁(page-level locking),但也支持表级锁;InnoDB存储引擎默认采用的是行级锁(row-level locking)，也支持表级锁  
1. 表级锁：开销小，加锁快，不会出现死锁；锁定粒度大，发生锁冲突的概率最高，并发度最低  
2. 行级锁：开销大，加锁慢，会出现死锁；锁定粒度小，发生锁冲突的概率最低，并发度最高  
3. 页面锁：开销和加锁时间介于表锁和行锁之间；会出现死锁；锁定粒度介于表锁和行锁之间，并发度一般  
BDB已经被InnoDB所取代  
## MyISAM表锁  
MyISAM存储引擎只支持表锁，不支持行锁和事务  
### 查看表锁争用情况  
`show status like '%table_locks%';`  
![title](https://raw.githubusercontent.com/liujinxi931204/image/master/gitnote/2020/08/26/1598429010951-1598429011016.png)  
其中如果Table_locks_waited的值比较高，则说明存在着较严重的表级锁争用情况  
### MyISAM表级锁的锁模式  
MyISAM的表级锁有两种模式：表共享读锁(Table Read Lock)和表独占写锁(Table Write Lock)  
![title](https://raw.githubusercontent.com/liujinxi931204/image/master/gitnote/2020/08/26/1598429287349-1598429287351.png)  
可见，对MyISAM存储引擎的表进行读操作，不会阻塞其他用户对同一表的读操作，但是会阻塞对同一表的写操作；对MyISAM表的写操作，则会阻塞其他用户对同一表的读操作和写操作；MyISAM表的读操作与写操作之间是串行的    
### 如何加表锁
1. 默认  
MyISAM在执行查询语句(select)前会自动给涉及的表加读锁；在执行更新语句(udpate、insert、delete)前会自动给涉及的表加写锁  
2. 显式给MyISAM表加锁  
显式加读锁  
`lock table table_name read`  
显示加写锁  
`lock table table_name write`  
3. 释放锁  
`unlock tables`会释放所有的表上的锁  
`unlock table table_name`释放表名为table_name表上的锁  
在用lock table给表显式地加锁时，必须同时取得所有涉及到表的锁，并且MySQL不支持锁升级。也就是说，在执行lock tables后，只能访问显示加锁的这些表，不能访问未加锁的表；同时，如果加的是读锁，那么只能执行查询操作，不能执行更新操作  
正是因为MyISAM总一次获得SQL语句的所需要的全部锁，MyISAM表不会出现死锁的情况  
当使用`lock table table_name read`锁定MyISAM表时，当前session不能查询被锁定表之外的表，也不能对锁定的表进行更新操作；别的session则可以继续给该表加读锁，但不能加写锁；当执行`unlock tables`后，只有当前session的读锁被释放，别的session读锁没有被释放  
当使用`lock table table_name write`锁定MyISAM表是，当前session可以执行查询、更新操作，但是不能访问锁定的表之外的表；别的session不能查询、更新这个表的数据  
当使用lock tables时，不仅需要一次锁定用到的所有的表，还需要锁定所有用到的表的别名  
`lock table actor as a read,actor as b read`  
### 并发插入  
在一定条件下，MyISAM也支持查询和插入操作的并发进行  
MyISAM存储引擎有一个系统变量concurrent_insert，专门用以控制其并发插入的行为，其值分别可以为0，1，2
+ 当concurrent_insert设置为0时，不允许并发插入  
+ 当concurrent_insert设置为1时，如果MyISAM表中没有空洞(即表的中间没有被删除的行)，MyISAM允许在一个进程读表的同时，另一个进程从表尾插入记录。这也是MyISAM的默认设置  
+ 当concurrent_insert设置为2时，无论MyISAM表中有没有空洞，都允许在表尾并发插入记录  
可以利用MyISAM存储引擎的并发插入特性，来解决应用中对同一表查询和插入的锁争用  
### MyISAM的锁调度  
MyISAM存储引擎是写进程优先，即使读请求先到锁等待队列，写请求后到，写锁也会插入到读锁请求之前。这也正是MyISAM表不太适合有大量更新操作和查询操作应用的原因，因为，大量的更新操作会造成查询插座很难获得锁，从而可能永久被阻塞  
## InnoDB锁  
### 获取InnoDB行锁争用情况  
![title](https://raw.githubusercontent.com/liujinxi931204/image/master/gitnote/2020/11/10/1604980673343-1604980673379.png)  
如果发现锁争用比较严重，如InnoDB_row_lock_waits和InnoDB_row_lock_time_avg的值比较高  
### InnoDB的行锁模式以及加锁方法  
InnoDB实现了一下两种类型的行锁  
+ 共享锁(S)：允许一个事务去读一行，阻止其他事务获得相同数据集的排他锁  
+ 排他锁(X)：允许获得排他锁的事务更新数据，阻止其他事务获得相同数据集的共享锁和排他锁  












