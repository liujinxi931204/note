## MySQL索引  
###  MySQL索引本质  
mysql索引的本质是数据结构。mysql在维护数据之外，还维护着满足特定查找算法的数据结构，这些数据结构以某种方式引用（指向数据）,这样就可以可以在这些数据结构上实现高级查找算法。这种数据结构就是索引  
### 索引的优势和劣势    
#### 索引的优势  
1. 提高查询效率，降低数据库IO成本  
2. 通过索引对数据排序，降低数据排序的成本，降低了CPU消耗  
#### 索引的劣势  
1. 索引实际也是一张表，该表保存了主键和索引字段，并指向实体表的记录，因此索引也是需要消耗磁盘空间的  
2. 虽然索引大大提高了查询速度，同时却会降低表的更新速度  
3. 索引只是提高数据库查询速度的一个因素  
### 索引的分类    
1. 单值索引：一个索引只包含单个列，一个数据表可以有多个单值索引  
2. 唯一索引：索引列的值必须唯一，但是可以为空值  
3. 复合索引：即一个所索引包含多个列  
### 索引的基本语法  
#### 创建索引    
`create [unique] index index_name on table_name(col_name(length));`  
`alter table table_name add [unique] index index_name on (col_name(length));`  
#### 添加索引  
`alter table table_name add primary key (col_list);`该语句添加主键索引，这意味着索引值必须是唯一的，而且不能为null  
`alter table table_name add unique index_name (col_list);`该语句添加唯一索引，索引的值必须是唯一的（除了null，null可以出现多次  
`alter table table_name add index index_name(col_list);`添加普通索引，索引值可以出现多次  
`alter table table_name add fulltext index_name (col_list);`添加全文索引  
#### 删除索引  
`drop index index_name on table_name;`  
#### 查看索引  
`show index from table_name \G`  
### 哪些情况下需要创建索引  
1. 主键自动建立唯一索引  
2.  频繁作为查询条件的字段应该建立索引  
3. 查询中与其他表关联的字段，外键关系建立索引  
4. 频繁更新的字段不适合创建索引(因为每次更新不单单是表的更新，还包括索引的更新)  
5. where条件里用不到的字段不创建索引  
6. 高并发情况下倾向于建立组合索引  
7. 查询中排序的字段，排序字段若通过索引去访问将大大提高排序速度  
8. 查询中分组或者统计的字段(分组的前提是必排序)  
### 哪些情况不要创建索引  
1. 表记录太少  
2. 频繁更新的表  
3. 数据重复且分布平均的表字段，例如：一个表有10万行记录，有一个字段只有T和F两种值，且每个值的分布概率大约为50%，那么对这个字段建立索引一般不会提高查询速度；索引的选择性是指索引列中不同值的数目与表记录行数的比值；如果一个表有2000行记录，表索引列有1980个不同的值，那么这个索引的选择性是1980/2000=0.99。一个索引的选择性约接近1，这个索引的效率越高  
### 索引为什么使用B-Tree(B+Tree)  
一般来说，索引本身也很大，不可能全部存储在内存中，因此索引往往以文件的形式存储在磁盘上。这样的话，索引的查找过程就要产生磁盘IO，相对于内存存取，磁盘IO的耗时要高好几个数量级。换句话说，索引的结构组织要尽量减少查找过程中磁盘的IO次数。  
![title](https://raw.githubusercontent.com/liujinxi931204/image/master/gitnote/2020/06/16/1592295546811-1592295546890.png)  
![title](https://raw.githubusercontent.com/liujinxi931204/image/master/gitnote/2020/06/16/1592295586485-1592295586488.png)  
根据B-Tree的定义，可知检索一次最多需要访问h个节点。数据库系统的设计者巧妙地利用磁盘预读原理，讲一个节点地大小设为等于一个页的大小，这样每个节点只需要一次IO就可以完全载入。B-Tree中一次检索最多需要h-1次IO(根节点常驻内存)，时间复杂度未O(h)=O(logdN)。一般应用中，出度d是非常大的数字，通过超过100，因此h非常小，通常不超过3  
### MyISAM索引实现  
MyISAM使用B+Tree作为索引结构，叶节点的data域存放的是数据记录的地址。  
![title](https://raw.githubusercontent.com/liujinxi931204/image/master/gitnote/2020/06/16/1592297292999-1592297293007.png)  
![title](https://raw.githubusercontent.com/liujinxi931204/image/master/gitnote/2020/06/16/1592297470994-1592297470996.png)  
MyISAM中检索的算法首先按照B+Tree搜索算法搜索索引，如果指定的Key存在，则取出其data域的值，然后以data域保存的值为地址，读取相应的记录。MyISAM的索引方式叶叫做"非聚集索引"  
### InnoDB索引实现  
![title](https://raw.githubusercontent.com/liujinxi931204/image/master/gitnote/2020/06/16/1592298857263-1592298857265.png)  
![title](https://raw.githubusercontent.com/liujinxi931204/image/master/gitnote/2020/06/16/1592298874655-1592298874657.png)  
InnoDB也使用B+Tree作为索引结构，但具体的实现方式却不相同  
1.InnoDB的数据文件本身就是索引文件，即InnoDB的叶子节点的data域保留着完整的数据行记录，这种索引也称为聚集索引。所以,InnoDB的数据文件本身要按照主键聚集，所以InnoDB要求表必须有主键(MyISAM可以没有)，如果没有显示指定，数据库会自动选择一个可以唯一标识数据记录的列作为主键，如果不存在，MySQL会自动生成一个隐含字段，这个字段的长度为6个字节，类型为长整型  
2.InnoDB的辅助索引的data域存储相应的记录主键的值而不是地址，换句话说，InnoDB的所有辅助索引都引用主键作为data域。聚集索引这种实现方式使得按照主键的搜索十分高效，但是辅助索引搜索需要检索两遍：首先检辅助索引获得主键，然后用主键到主索引中检索获得记录。
### explain  
explain关键字可以模拟MySQL优化器执行SQL语句，可以很好的分析SQL语句或表结构的性能瓶颈  
#### explain可以做哪些事情  
1. 表的读取顺序  
2. 数据读取操作的操作类型  
3. 哪些索引可以用  
4. 哪些索引被实际使用  
5. 表之间的引用  
6. 每张表有多少行被优化器查询  
#### 执行计划包含的信息  
![title](https://raw.githubusercontent.com/liujinxi931204/image/master/gitnote/2020/08/12/1597225230435-1597225230443.png)  
#### 字段解释  
##### id  
select查询的序列号，包含一组数字，表示查询中执行select子句或操作表的顺序  
1. id相同，执行顺序由上而下  
![title](https://raw.githubusercontent.com/liujinxi931204/image/master/gitnote/2020/08/11/1597076002574-1597076002577.png)
2. id不同，如果是子查询，id的序号会递增，id值越大优先级越高，越先被执行  
![title](https://raw.githubusercontent.com/liujinxi931204/image/master/gitnote/2020/08/11/1597076040885-1597076040888.png)
3. id相同不同，同时存在。id相同可以认为是一组，查询顺序由上而下，在所有组中id越大，执行的优先级越高，越先被执行  
![title](https://raw.githubusercontent.com/liujinxi931204/image/master/gitnote/2020/08/11/1597075941610-1597075941612.png)  
##### sellect_type  
查询的类型，主要用于区别普通查询、联合查询、子查询等的复杂查询  
1. SIMPLE，简单的select查询，查询中不包含子查询或者union查询  
![title](https://raw.githubusercontent.com/liujinxi931204/image/master/gitnote/2020/08/11/1597158395291-1597158395561.png)  
2. PRIMARY，查询中若包含任意复杂的子部分，最外层查询则被标记为primary；可以认为是最后执行加载的  
![title](https://raw.githubusercontent.com/liujinxi931204/image/master/gitnote/2020/08/11/1597076040885-1597076040888.png)
3. SUBQUERY，在select或where列表中包含了子查询  
![title](https://raw.githubusercontent.com/liujinxi931204/image/master/gitnote/2020/08/11/1597076040885-1597076040888.png)
4. DERIVED，在from列表中包含的子查询被标记为derived(衍生)。mysql会递归执行这些子查询，把结果放在临时表里  
![title](https://raw.githubusercontent.com/liujinxi931204/image/master/gitnote/2020/08/11/1597075941610-1597075941612.png)
5. UNION，若第二个select出现在union之后，则被标记为union；若union包含在from子句中，外层select被标记为derived
![title](https://raw.githubusercontent.com/liujinxi931204/image/master/gitnote/2020/08/11/1597160750371-1597160750375.png)
6. UNION RESULT，从union中表中获取结果的select  
![title](https://raw.githubusercontent.com/liujinxi931204/image/master/gitnote/2020/08/11/1597160750371-1597160750375.png)
##### type  
显示查询使用了什么类型，从最好到最差依次是NULL>system>const>range>eq_ref>ref>index>ALL  
1. NULL： MySQL能够在优化阶段分解查询语句，在执行阶段不再访问表或索引  
![title](https://raw.githubusercontent.com/liujinxi931204/image/master/gitnote/2020/08/12/1597200383869-1597200384068.png)  
2. system：表只有一行记录(相当于系统表)，这是const类型的特例，平时不会出现，可以忽略不记  
3. const：表示通过索引一次就找到了，const用于比较primary key或者unique索引。因为只匹配一行数据，所以很快，如将主键置于where列中，MySQL就能将该查询转换为一个常量（简单说，直接按照主键或者唯一键读取）  
![title](https://raw.githubusercontent.com/liujinxi931204/image/master/gitnote/2020/08/12/1597201115733-1597201115735.png)  
4. eq_ref：唯一性索引扫描，对于每个索引键，表中只有一条记录与之匹配，常见于主键或唯一索引扫面(一般用于连表查询的情况，按连表的主键或唯一键联合查询)  
![title](https://raw.githubusercontent.com/liujinxi931204/image/master/gitnote/2020/08/12/1597214522112-1597214522115.png)  
5. ref：非唯一性索引扫描，返回单独匹配某个值的所有行。本质上也是一种索引访问，它返回所有匹配某个单独值的行，然而，他可能找到多个符合条件的行，所以他应该属于查找和扫描的混合体  
![title](https://raw.githubusercontent.com/liujinxi931204/image/master/gitnote/2020/08/12/1597215204949-1597215204951.png)  
6. range：只检索给定范围的行，使用一个索引来选择行。key列显示了使用了哪个索引，一般就是在你的where子句中出现的between，<,>,in等的查询，这种范围查询要比全表扫描要好，因为它只需要开始于索引的某一点，而结束语另一点，不用扫描全列  
![title](https://raw.githubusercontent.com/liujinxi931204/image/master/gitnote/2020/08/12/1597215561492-1597215561494.png)  
7. index：index与ALL的区别为index类型只遍历索引树。这通常比ALL快，因为索引文件通常比数据文件小。也就是说，虽然index和ALL都会读全表，但是index是从索引文件中读取，而ALL是从硬盘中读取  
![title](https://raw.githubusercontent.com/liujinxi931204/image/master/gitnote/2020/08/12/1597215872094-1597215872099.png)  
8. ALL： 将遍历全表以找到匹配的行  
![title](https://raw.githubusercontent.com/liujinxi931204/image/master/gitnote/2020/08/12/1597215948326-1597215948328.png)  一般来说，至少达到range级别，最好能够达到ref级别  
##### possible_keys  
显示可能应用在这张表上的索引，可能是一个或者多个，查询涉及的字段上如果存在索引，将会被列出，但不一定被查询使用  
##### key  
实际使用的索引。如果为NULL，则没有使用索引；查询中如果使用了覆盖索引(查询的列刚好是索引)，则该索引仅出现在key列中  
##### key_len  
表示索引中使用的字节数，可通过该列计算查询中使用的索引的长度。在不损失精确性的前提下，长度越短越好。key_len显示的值为索引字段的最大可能长度，并非实际使用长度，即key_len是根据表定义计算得出的，不是通过表内检索出的  
##### ref  
显示索引的哪一列被使用了，如果可能的话，是一个常数。哪些列或常量被用于查找索引列上的值  
##### rows  
根据表统计信息及索引选用情况，大致估算出找到所需的记录所需要读取的行数  
##### Extra  
包含不适合在其他列中显示，但又十分重要的额外信息(如果出现using filesort 或者using tempporary则说明需要优化)  
1. using filesort：说明MySQL会对数据使用一个外部的排序，而不是按照表内部的索引顺序进行读取，MySQL无法利用索引完成的排序成为"文件排序"  
![title](https://raw.githubusercontent.com/liujinxi931204/image/master/gitnote/2020/08/12/1597222615825-1597222615827.png)  
2. using temporary：使用了临时表保存中间结果，MySQL在对结果排序时使用临时表，常见于排序order by和分组查询group by  
![title](https://raw.githubusercontent.com/liujinxi931204/image/master/gitnote/2020/08/12/1597223141305-1597223141308.png) 
3. using index： 表明相应的select使用了覆盖索引，避免访问了表的数据行，效率不错！  
如果同时出现using where，表明索引被用来执行索引键值的查找  
如果没有出现using where，表明索引用来读取数据而非执行查找动作  
![title](https://raw.githubusercontent.com/liujinxi931204/image/master/gitnote/2020/08/12/1597224060690-1597224060696.png)  
4. using where：表明使用了where条件  
5. using join buffer：表示使用了连接缓存  
6. impossible where：表明where条件总为false，不能用来获取任何元组  
7. distinct：一旦MySQL找到了与行相联合匹配的行，就不再搜索了  
8. Select tables optimized away：SELECT操作已经优化到不能再优化了（MySQL根本没有遍历表或索引就返回数据了）  
![title](https://raw.githubusercontent.com/liujinxi931204/image/master/gitnote/2020/08/12/1597224253586-1597224253588.png)
## 慢查询  
### 开启慢SQL查询日志  
`show variables like '%slow_query%';`  
![title](https://raw.githubusercontent.com/liujinxi931204/image/master/gitnote/2020/08/23/1598194908128-1598194908131.png)  
默认情况下，slow_query_log为off,表示没有开启慢查询日志；slow_query_log_file是慢查询日志的记录日志的位置，默认位于/var/lib/mysql/下  
开启慢查询日志的方式有两种：  
1. 命令行开启(重启失效，推荐使用)  
`set global slow_query_log=1;`  
2. 配置文件开启(永久生效)    
```shell
vim my.cnf
在[mysqld]下添加
slow_query_log=1
slow_query_log_file=/var/lib/hbhly_58_128-slow.log
重启mysql服务
```  
### 慢SQL查询阈值  
`show variables like '%long_query_time%';`  
![title](https://raw.githubusercontent.com/liujinxi931204/image/master/gitnote/2020/08/23/1598195552167-1598195552170.png)  
默认慢查询的时间阈值是10秒  
修改慢查询时间阈值的方式有两种  
1. 命令行的方式(重启失效，推荐)  
`set global long_query_time=3;`设置慢查询时间阈值为3秒  
2. 修改配置文件  
```shell
vim my.cnf  
在[mysqld]下面添加
long_query_time=3
log_output=FILE
重启mysql
```  
### 如何把未使用索引的SQL记录写入慢查询日志  
`show variables like 'log_queries_not_using_indexes'`,默认情况下没有开启
![title](https://raw.githubusercontent.com/liujinxi931204/image/master/gitnote/2020/08/23/1598197159816-1598197159819.png)  
### 日志分析工具mysqldumpslow  
![title](https://raw.githubusercontent.com/liujinxi931204/image/master/gitnote/2020/08/23/1598197357251-1598197357256.png)   
### show profile  
####  查看show profile  
`show variables like '%profiling%';`  
![title](https://raw.githubusercontent.com/liujinxi931204/image/master/gitnote/2020/08/23/1598197602283-1598197602287.png)  
其中profiling 默认没有开启，默认查看最近15次记录   
开启profiles  
`set profiling=1; `  
查询最近15次记录  
![title](https://raw.githubusercontent.com/liujinxi931204/image/master/gitnote/2020/08/23/1598198299417-1598198299420.png)  
运行诊断的SQL  
```shell
命令 show profiles cpu,block io for query id
例如：
show profiles cpu ,block io for query 3;

```


























































