## MySQL索引  
###  MySQL索引本质  
mysql索引的本质是数据结构。mysql在维护数据之外，还维护着满足特定查找算法的数据结构，这些数据结构以某种方式引用（指向数据）,这样就可以可以在这些数据结构上实现高级查找算法。这种数据结构就是索引  
### 索引的优势和劣势    
#### 索引的优势  
1. 提高查询效率，降低数据库IO成本  
2. 通过索引对数据排序，降低数据排序的成本，降低了CPU消耗  
#### 索引的劣势  
1. 索引实际也是一张表，该表保存了主键和索引字段，并指向实体表的记录，因此索引也是需要消耗磁盘空间的  
2. 虽然索引大大提高了查询速度，同时却会降低表的更新速度  
3. 索引只是提高数据库查询速度的一个因素  
### 索引的分类    
1. 单值索引：一个索引只包含单个列，一个数据表可以有多个单值索引  
2. 唯一索引：索引列的值必须唯一，但是可以为空值  
3. 复合索引：即一个所索引包含多个列  
### 索引的基本语法  
#### 创建索引    
`create [unique] index index_name on table_name(col_name(length));`  
`alter table table_name add [unique] index index_name on (col_name(length));`  
#### 添加索引  
`alter table table_name add primary key (col_list);`该语句添加主键索引，这意味着索引值必须是唯一的，而且不能为null  
`alter table table_name add unique index_name (col_list);`该语句添加唯一索引，索引的值必须是唯一的（除了null，null可以出现多次  
`alter table table_name add index index_name(col_list);`添加普通索引，索引值可以出现多次  
`alter table table_name add fulltext index_name (col_list);`添加全文索引  
#### 删除索引  
`drop index index_name on table_name;`  
#### 查看索引  
`show index from table_name \G`  
### 哪些情况下需要创建索引  
1. 主键自动建立唯一索引  
2.  频繁作为查询条件的字段应该建立索引  
3. 查询中与其他表关联的字段，外键关系建立索引  
4. 频繁更新的字段不适合创建索引(因为每次更新不单单是表的更新，还包括索引的更新)  
5. where条件里用不到的字段不创建索引  
6. 高并发情况下倾向于建立组合索引  
7. 查询中排序的字段，排序字段若通过索引去访问将大大提高排序速度  
8. 查询中分组或者统计的字段(分组的前提是必排序)  
### 哪些情况不要创建索引  
1. 表记录太少  
2. 频繁更新的表  
3. 数据重复且分布平均的表字段，例如：一个表有10万行记录，有一个字段只有T和F两种值，且每个值的分布概率大约为50%，那么对这个字段建立索引一般不会提高查询速度；索引的选择性是指索引列中不同值的数目与表记录行数的比值；如果一个表有2000行记录，表索引列有1980个不同的值，那么这个索引的选择性是1980/2000=0.99。一个索引的选择性约接近1，这个索引的效率越高  
### 索引为什么使用B-Tree(B+Tree)  
一般来说，索引本身也很大，不可能全部存储在内存中，因此索引往往以文件的形式存储在磁盘上。这样的话，索引的查找过程就要产生磁盘IO，相对于内存存取，磁盘IO的耗时要高好几个数量级。换句话说，索引的结构组织要尽量减少查找过程中磁盘的IO次数。  
![title](https://raw.githubusercontent.com/liujinxi931204/image/master/gitnote/2020/06/16/1592295546811-1592295546890.png)  
![title](https://raw.githubusercontent.com/liujinxi931204/image/master/gitnote/2020/06/16/1592295586485-1592295586488.png)  
根据B-Tree的定义，可知检索一次最多需要访问h个节点。数据库系统的设计者巧妙地利用磁盘预读原理，讲一个节点地大小设为等于一个页的大小，这样每个节点只需要一次IO就可以完全载入。B-Tree中一次检索最多需要h-1次IO(根节点常驻内存)，时间复杂度未O(h)=O(logdN)。一般应用中，出度d是非常大的数字，通过超过100，因此h非常小，通常不超过3  
### MyISAM索引实现  
MyISAM使用B+Tree作为索引结构，叶节点的data域存放的是数据记录的地址。  
![title](https://raw.githubusercontent.com/liujinxi931204/image/master/gitnote/2020/06/16/1592297292999-1592297293007.png)  
![title](https://raw.githubusercontent.com/liujinxi931204/image/master/gitnote/2020/06/16/1592297470994-1592297470996.png)  
MyISAM中检索的算法首先按照B+Tree搜索算法搜索索引，如果指定的Key存在，则取出其data域的值，然后以data域保存的值为地址，读取相应的记录。MyISAM的索引方式叶叫做"非聚集索引"  
### InnoDB索引实现  
![title](https://raw.githubusercontent.com/liujinxi931204/image/master/gitnote/2020/06/16/1592298857263-1592298857265.png)  
![title](https://raw.githubusercontent.com/liujinxi931204/image/master/gitnote/2020/06/16/1592298874655-1592298874657.png)  
InnoDB也使用B+Tree作为索引结构，但具体的实现方式缺不相同  
1.InnoDB的数据文件本身就是索引文件，即InnoDB的叶子节点的data域保留着完整的数据行记录，这种索引也称为聚集索引。所以,InnoDB的数据文件本身要按照主键聚集，所以InnoDB要求表必须有主键(MyISAM)可以没有，如果没有显示指定，数据库会自动选择一个可以唯一标识数据记录的列作为主键，如果不存在，MySQL会自动生成一个隐含字段，这个字段的长度为6个字节，类型为长整型  
2.InnoDB的辅助索引的data域存储相应的记录主键的值而不是地址，换句话说，InnoDB的所有辅助索引都引用主键作为data域。聚集索引这种实现方式使得按照主键的搜索十分高效，但是辅助索引搜索需要检索两遍：首先检辅助索引获得主键，然后用主键到主索引中检索获得记录。
### explain  
explain关键字可以模拟MySQL优化器执行SQL语句，可以很好的分析SQL语句或表结构的性能瓶颈  
#### explain可以做哪些事情  
1. 表的读取顺序  
2. 数据读取操作的操作类型  
3. 哪些索引可以用  
4. 哪些索引被实际使用  
5. 表之间的引用  
6. 每张表有多少行被优化器查询  
#### 执行计划包含的信息  
| id | select_type | table | type | possible_keys | key | key_len | ref | rows | Extra |
|-|-|-|-|-|-|-|-|-|-|-|
#### 字段解释  
##### id  
select查询的序列号，包含一组数字，表示查询中执行select子句或操作表的顺序  
1. id相同，执行顺序由上而下  
![title](https://raw.githubusercontent.com/liujinxi931204/image/master/gitnote/2020/08/11/1597076002574-1597076002577.png)
2. id不同，如果是子查询，id的序号会递增，id值越大优先级越高，越先被执行  
![title](https://raw.githubusercontent.com/liujinxi931204/image/master/gitnote/2020/08/11/1597076040885-1597076040888.png)
3. id相同不同，同时存在。id相同可以认为是一组，查询顺序由上而下，在所有组中id越大，执行的优先级越高，越先被执行  
![title](https://raw.githubusercontent.com/liujinxi931204/image/master/gitnote/2020/08/11/1597075941610-1597075941612.png)  
##### sellect_type  
查询的类型，主要用于区别普通查询、联合查询、子查询等的复杂查询  
1. SIMPLE，简单的select查询，查询中不包含子查询或者union查询  
![title](https://raw.githubusercontent.com/liujinxi931204/image/master/gitnote/2020/08/11/1597158395291-1597158395561.png)  
2. PRIMARY，查询中若包含任意复杂的子部分，最外层查询则被标记为primary；可以认为是最后执行加载的  
![title](https://raw.githubusercontent.com/liujinxi931204/image/master/gitnote/2020/08/11/1597076040885-1597076040888.png)
3. SUBQUERY，在select或where列表中包含了子查询  
![title](https://raw.githubusercontent.com/liujinxi931204/image/master/gitnote/2020/08/11/1597076040885-1597076040888.png)
4. DERIVED，在from列表中包含的子查询被标记为derived(衍生)。mysql会递归执行这些子查询，把结果放在临时表里  
![title](https://raw.githubusercontent.com/liujinxi931204/image/master/gitnote/2020/08/11/1597075941610-1597075941612.png)
5. UNION，若第二个select出现在union之后，则被标记为union；若union包含在from子句中，外层select被标记为derived
![title](https://raw.githubusercontent.com/liujinxi931204/image/master/gitnote/2020/08/11/1597160750371-1597160750375.png)
6. UNION RESULT，从union中表中获取结果的select  
![title](https://raw.githubusercontent.com/liujinxi931204/image/master/gitnote/2020/08/11/1597160750371-1597160750375.png)
#### type  
显示查询使用了什么类型，从最好到最差依次是NULL>system>const>range>eq_ref>ref>index>ALL  
1. NULL： MySQL能够在优化阶段分解查询语句，在执行阶段不再访问表或索引  
![title](https://raw.githubusercontent.com/liujinxi931204/image/master/gitnote/2020/08/12/1597200383869-1597200384068.png)  
2. system：表只有一行记录(相当于系统表)，这是const类型的特例，平时不会出现，可以忽略不记  
3. const：表示通过索引一次就找到了，const用于比较primary key或者unique索引。因为只匹配一行数据，所以很快，如将主键置于where列中，MySQL就能将该查询转换为一个常量  
![title](https://raw.githubusercontent.com/liujinxi931204/image/master/gitnote/2020/08/12/1597201115733-1597201115735.png)  
4. eq_ref：唯一性索引扫描，对于每个索引键，表中只有一条记录与之匹配，常见于主键或唯一索引扫面(一般用于连表查询的情况，)

### 最左前缀原理与相关优化  
以上说的索引都是单一索引，实际上，MySQL中的索引可以以一定顺序引用多个列，这个索引叫做联合索引。  
以下是一个例子  
![title](https://raw.githubusercontent.com/liujinxi931204/image/master/gitnote/2020/06/16/1592299728720-1592299728722.png)  
从结果中可以看出titles表的主索引是一个联合索引(emp_no,title,from_date),还有一个辅助索引。下面主要分析索引PRIMARY的行为  
#### 全列匹配  
`explain select * from employees.titles where emp_no='10001' and title='Senior Engineer' and from_date='1986-06-26';`    
![title](https://raw.githubusercontent.com/liujinxi931204/image/master/gitnote/2020/06/16/1592299973321-1592299973328.png)  




















































