前面提到了一些经典的设计原则，其中包括，SOLID，KISS，DRY，LOD原则等。这些设计原则，从字面上理解，都不难。但是，"看懂"和"会用"是两回事，而"用好"更是难上加难。在使用的时候过于教条主义，拿原则当真理，生搬硬套，则可能会适得其反。  

实际上SOLID原则并非单纯的一个原则，而是由五个设计原则组成的。它们分别是单一职责原则、开闭原则、里氏替换原则、接口隔离原则和依赖反转原则。

### 单一职责原则（SRP）  

单一职责原则的因为是Single Responsibility Principle，缩写为SRP。这个原则的英文描述为："A class or module should have a single responsibility"。翻译成中文就是："一个类或者模块只负责完成一个职责（或者功能）"。这个原则描述的对象有两个，一个是类（class）,另一个是模块（module）。一种理解可以把模块看成是比类更加抽象的概念，类也可以看作一个模块；另外一种理解是：把模块看作比类更加粗粒度的代码块，模块中包含多个类，多个类组成一个模块

单一职责原则的定义描述非常简单，也不难理解。一个类只负责完成一个职责或者功能。也就是说，不要设计大而全的类，要设计粒度小、功能单一的类。换个角度讲就是，一个类包含了两个或者以上业务不相干的功能，那我们就说它职责不够单一，应该将它拆分成多个功能更加单一、粒度更细的类  

不同的应用场景、不同阶段的需求背景下，对同一个类的职责是否单一的判定，可能都是不一样的。在某种应用场景或者当下的需求背景下，一个类的设计可能已经满足单一职责原则了，但如果换个应用场景或者在未来的某个需求背景下，可能就不满足了，需要继续拆分成粒度更细的类。除此之外，从不同的业务层面去看待同一个类的设计，对类是否单一职责，也会有不同的认识  

综上所述，评价一个类的职责是否足够单一，并没有一个非常明确的、可以量化的标准，可以说，这是件非常主观的、仁者见仁智者见智的事情。实际上，也没有必要过于未雨绸缪，过度设计。**可以先写一个粗粒度的类，满足业务需求。随着业务的发展，如果粗粒度的类越来越庞大，代码越来越多，这个时候，就可以将这个粗粒度的类，拆分成几个更细粒度的累，这就是所谓的持续重构**  

下面几条判断原则，比起主观地去思考类是否职责单一，更有指导意义、更具有可执行性  

+ 类中的代码行数、函数或者属性过多，会影响到代码的可读性和可维护性，我们就需要考虑对类进行拆分  

+ 类依赖的其他类过多、或者依赖类的其他类过多，不符合高内聚、低耦合的设计思想，可以考虑对类进行拆分  

+ 私有方法过多，可以考虑将私有方法独立到新的类中，设置为public方法，供更多的类使用，从而提高代码的复用性  

+ 比较难给一个类起一个适合的名字，很难用一个业务名词概括，或者只能用一些比较笼统的Manager、Context之类的词语命名，这就说明类的职责定义得可能不够清晰  

+ 类中大量的方法都是集中操作类中的某几个属性，那么可以考虑将这几个方法和对应的属性拆分出来  

单一职责原则通过避免设计大而全的类，避免将不相关的功能耦合在一起，来提高类的内聚性。同时，类职责单一，类依赖的和被依赖的其他类也会变少，减少了代码的耦合性，以此来实现代码的高内聚，低耦合。但是，如果拆分的过细，实际上会适得其反，反倒会降低内聚性，也会影响代码的可维护性  

### 开闭原则 （OCP）  

开闭原则的英文全称是Open Closed Principle，简称OCP。它的英文描述是：software entities（modules、classes、functions、etc）should be open for extension，but closed for modification。翻译成中文就是：软件实体（模块、类、方法等）应该对扩展开放、对修改关闭。换个角度描述一下就是添加一个新的功能应该是在，已有的代码的基础上扩展代码（新增模块、类、方法等），而非修改已有的代码（模块、类、方法等） 

在23中经典设计模式中，大部分设计模式都是为了解决代码的扩展性问题而存在的，主要遵从的设计原则就是开闭原则  

如何理解"对扩展开放，对修改关闭"？我们要时刻具备扩展意识，抽象意识、封装意识。在写代码的时候，要多花时间思考一下，这段代码未来可能有哪些需求变更，如何设计代码结构，事先留好扩展点，以便在未来需求变更的时候，在不改动代码整体结构、做到最小代码改动的情况下，将新的代码灵活地插入到扩展点上  

实际上，在众多的设计原则、思想、模式中，最常用来提高代码扩展性的方法有：多态、依赖注入、基于接口而非实现变成、以及大部分的设计模式（比如：装饰、策略、模板、职责链、状态等）。

修改代码就意味着违背开闭原则？实际上，我们也没有必要纠结某个代码改动是"修改"还是"扩展"，更没有必要太纠结它是否违背了"开闭原则"。我们回到这条设计原则的设计初衷：只要它没有破坏原有的代码的正常运行，没有破坏原有的单元测试，我们就可以说，这是一个合格的代码改动  

如何在项目中灵活应用开闭原则？最合理的做法是，对一些比较确定的、短期内可能就会扩展、或者需求改动对代码结构影响较大的情况，或者实现成本不高的扩展点，在编写代码的时候，可以事先做写扩展性设计。但对于一些不确定未来是否要支持的需求、或者实现起来比较复杂的扩展点，可以等到有需求驱动的时候，再通过重构代码的方式来支持扩展。而且开闭原则也不是免费的。有些情况下，代码的扩展性会跟可读性相冲突。这就需要在扩展性和可读性之间做权衡，某些场景下，代码的扩展性很重要，我们就适当的牺牲一些代码的可读性；在另一些场景下，代码的可读性更加重要，那我们就适当牺牲一些代码的扩展性  

### 里氏替换原则（LSP）  

里氏替换原则的英文的全称是Liskov Substitution Principle，缩写为LSP。这个原则最早是Barbara Liskov提出的，他是这么描述这条原则的"If S is a subtype of T,then objects of type T may be replaced with objects of type S,without breaking the program"。后来，Robert Martin在他的SOLID原则中，重新描述了这个原则，英文原文是这样的：Functions that use pointers of reference to base classes must be able to use objects of derived classes without knowing it。

我们综合两者的描述，将这条原则用中文描述：子类对象能够替换程序中父类对象出现的任何地方，并且能够保证原来程序的逻辑行为不变以及正确性不被破坏  

不过，我们发现这条原则和多态有点类似。那是不是说里氏替换原则和多态是一回事呢？虽然从定义上来说，多态和里氏替换原则有点类似，但是它们关注的角度是不一样的。多态是棉线对象编程的一大特性，也是面向对象编程语言的一种语法，它是代码实现的一种思路。而历史替换原则是一种设计原则，是用来指导继承关系中子类该如何设计的，子类的设计要保证在替换父类的时候，不改变原有程序逻辑以及不破坏原有程序的正确性  

哪些代码明显违背了LSP  

实际上，里氏替换原则还有另一个更加能落地、更有指导意义的描述，那就是"Design By Contract"，中文翻译就是"按照协议来设计"  

子类在设计的时候，要遵从父类的行为约定（或者叫协议）。父类定义了函数的行为约定，那子类可以改变函数的内部实现逻辑，但不能改变函数原有的行为约定。这里的行为约定包括：函数声明要实现的功能；对输入、输出、异常的约定；甚至包括注释中所罗列的任何特殊说明。实际上，定义中父类和子类之间的关系，也可以替换成接口和实现类的关系  

1. 子类违背父类声明要实现的功能  

父类中提供的`sortOrdersByAmount()`订单排序函数，是按照金额从小到大来给订单排序的，而子类重写这个`sortOrdersByAmount()`订单排序函数之后，是按照订单创建日期来订单排序的，那么这个子类的设计就违背了里氏替换原则  

2. 子类违背父类对输入、输出、异常的约定  

在父类中，某个函数约定：运行出错的时候要返回`null`；获取数据为空的时候返回空集合。而子类重载函数之后，实现改变了，运行出错返回异常，获取不到数据返回`null`。那子类的设计就违背了里氏替换原则  

在父类中，某个函数约定，输入数据可以是任意整数，但子类实现的时候，只允许输入数据是正整数，负数就抛出异常，也就是说，子类对输入的数据校验比父类更加严格，那子类的设计就违背了里氏替换原则  

在父类中，某个函数约定，只会抛出`ArgumentNullException`异常，那子类的设计实现中只允许抛出`ArgumentNullException`异常，任何其他异常的抛出都会导致子类违背里氏替换原则  

3. 子类违背父类注释中所罗列的任何特殊说明  

父类中定义的`withDraw()`提现函数的注释是这么写的："用户的提现金额不得超过超过余额。。。"，而子类重写`withDraw()`函数只会，针对VIP账号实现了透支体现的功能，也就是提现金额可以大于账户余额，那么这个子类的设计也是不符合里氏替换原则的  

除此之外，判断子类的设计实现是否违背了里氏替换原则，可以使用父类的单元测试去验证子类的代码。如果某些单元测试运行失败，就有可能说明，子类的实现没有完全地遵守父类的约定，子类有可能违背了里氏替换原则  

### 接口隔离原则（ISP）  

接口隔离原则的英文翻译是"Interface Segregation Principle"，缩写为ISP。Robert Martin在SOLID原则中是这样定义的："Clients should not be forced to depend upon interfaces that they do not use"。直译成中文就是："客户端不应该被强迫依赖它所不需要的接口"。这里客户端可以理解为接口的调用者或者使用者  

这里我们可以把接口理解为下面三种东西  

+ 一组API接口集合  

+ 单个API接口或函数  

+ OOP中的接口概念  

如果把"接口"理解为一组接口集合，可以是某个微服务的接口，也可以是某个类库的接口等。如果部分接口只被部分调用者使用，我们就需要将这部分接口隔离出来，单独给这部分接口调用者，而不强迫其他调用者也依赖这部分不会被用到的接口  

如果把"接口"理解为单个API接口或函数，部分调用者只需要函数中的部分功能，那我们就需要把函数拆分成粒度更细的多个函数，让调用者只依赖它需要的那个细粒度函数  

如果把"接口"理解为OOP中的接口，也可以理解为面向对象编程中的接口语法。那接口的设计要尽量单一，不要让接口的实现类和调用者，依赖不需要的接口函数  

接口隔离原则与单一职责原则的区别  

单一职责原则针对的是模块、类、接口的设计。接口隔离原则相对于单一职责原则，一方面更侧重接口的设计，另一方面它的思考角度也是不同的。接口隔离原则提供了一种判断接口的职责是否单一的标准：通过调用者如何使用接口来间接地判定。如果调用者只使用部分接口或接口的部分功能，那接口的设计就不够职责单一  

### 依赖反转原则（DIP）

依赖反转原则的英文翻译是："High-Level modules shouldn't depend on Low-Level modules. Both modules should depend on abstractions. In addition, abstractions shouldn't depend on details. Details depend on abstractions. "翻译成中文就是："高层模块不要依赖低层模块。高层模块和低层模块之间应该通过抽象来互相依赖。除此之外，抽象不要依赖具体实现细节，具体实现细节依赖抽象"  

一个复杂的系统必然存在高层与低层，并且，高层对象使用低层对象为其提供的“服务”来实现自己的业务逻辑，即所谓的高层依赖低层。但如果高层对象直接使用这些低层对象（的具体实现），当业务变化，而低层的已有实现无法满足高层的服务需求时，那就需要“伤筋动骨”。为了避免这样的问题，人们提出了面向（依赖）接口编程，这样只要接口不发生变化，低层的实现不会影响上层的使用。

![设计原则DIP](https://gitee.com/liujinxi931204/typoraImage/raw/master/img/%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99DIP.png)  

图1中，高层对象A依赖于底层对象B的实现；图2中，把高层对象A对底层对象的需求抽象为一个接口A，底层对象B实现了接口A，这就是依赖反转。

例如Tomcat是运行Java Web应用程序的容器。我们编写的Web应用程序代码只需要部署在Tomcat容器下，就可以被Tomcat容器运行。按照之前划分的原则，Tomcat就是高层模块，我们编写的Web程序代码就是低层模块。Tomcat和应用程序代码之间没有直接的依赖关系，两者都依赖同一个"抽象"，也就是Servlet规范。Servlet规范不依赖具体的Tomcat容器和应用程序实现细节，而Tomcat容器和应用程序依赖Servlet规范。

### KISS原则  

KISS原则的英文描述有好几个版本，比如"keep it simple and stupid"，翻译成中文就是尽可能地保持简单。我们知道代码的可读性和可维护性是衡量代码质量的非常重要的两个标准。而KISS原则就是保持代码可读和可维护的重要手段。代码足够简单，也就意味着很容易读懂，bug比较难隐藏。即便出现bug，修复起来也比较简单  

不能说代码行数越少就越符合KISS原则，也不能说代码逻辑越复杂就违背KISS原则。

如何写出满足KISS原则的代码？  

+ 不要使用同事可能不懂的技术来实现代码。比如一些复杂的正则表达式、一些编程语言中过于高级的语法等  

+ 不要重复造轮子，要善于使用已经有的工具库类。经验证明，自己去实现这些类库，出bug的概率会更高，维护的成本也比较高  

+ 不要过度优化。不要过度使用一些奇淫技巧（比如位运算代替算数运算，复杂的条件语句代替if-else，使用一些底层的函数等）来优化代码，牺牲代码的可读性  

实际上，代码是否足够简单是一个挺主观的评判。反而是，在做开发的时候，不要过度设计，不要觉得简单的东西就没有技术含量。事实上，越是能用简单的方法解决复杂的问题，越能体现一个人的能力  

### YANGI原则  

YANGI原则的英文全称是："You Ain't Gonna Need It. "。翻译成中文的意思就是，不要去设计当前用不到的功能；不要去编写当前用不到的代码。实际上，这条原则的核心思想就是不要过度设计  

YANGI是说不要过度设计，而不是不要考虑代码的可扩展性。  

从上面的分析可以知道，KISS原则是"如何做"的问题（尽量保持简单），而YANGI原则说的是"要不要做"的问题（当前不需要的就不要做）  

### DRY原则  

DRY原则的英文全称是："Don't Repeat Yourself"。

首先来区分三个概念：代码复用性（Code Resuability），代码复用（Code Resue）和DRY原则  

代码复用表示一种行为：在开发新功能的时候，尽量复用已经存在的代码。代码的可复用性表示一段代码可被复用的特性或能力：在编写代码的时候，让代码尽量可复用。DRY原则是一条原则：不要写重复的代码。

首先，**"不重复"并不代表"可复用"**。在一个项目代码中，可能不存在任何重复的代码，但是也不并不代表这里有可复用的代码，不重复和可复用是两个两个完全不同的概念。所以，从这个角度来讲，DRY原则跟代码的可复用性讲的是两回事  

其次，复用"和"可复用性"关注的角度不同。代码的"复用性"是从代码开发者的角度来讲的，"复用"是从代码使用者的角度来讲的。  

尽管复用、可复用性、DRY原则这三者从理解上有所区别，但实际上要达到的目的都是类似的，都是为了减少代码量，提高代码的可读性、可维护性。除此之外，复用已经经过测试的老代码，bug会比从零重新开发要少  

怎么提高代码复用性  

+ 减少代码耦合  
  对于高耦合度的代码，当我们希望复用其中的一个功能时，想把这个功能的代码抽取出来成为一个独立的模块、类或者函数时，往往发现会牵一发而动全身。移动一点代码，就要牵连到很多其他相关的代码。所以，高耦合度的代码会影响到代码的复用性，我们要尽量减少代码耦合  
  
+ 满足单一职责原则  

  如果职责不够单一，模块、类设计得大而全，那依赖它的代码或者它依赖的代码就会比较多，进而增加代码的耦合。根据上一点，也就会降低代码的复用性。相反，越细粒度的代码，代码的通用性会越好，越容易被复用

+ 模块化  

  这里的"模块化"，不单单指一组类构成的模块，还可以理解为单个类，函数。我们要善于将功能独立的代码，封装成模块，独立的模块。独立的模块就想一块一块的积木，更加容易复用，可以直接拿来搭建更加复杂的系统  

+ 业务与非业务逻辑分离  

  越是跟业务无关的代码越容易复用，越是针对特定业务的代码越难复用。所以，为了复用跟业务无关的代码，我们将业务和非业务逻辑代码分离，抽取一些通用的框架、类库、组件等  

+ 通用代码下沉  

  从分层的角度来看，越底层的越通用、会被越多的模块调用，越应该设计得足够可复用。一般情况下，在代码分层之后，为了避免交叉调用导致关系混乱，我们只允许上层代码调用下层代码以及同层代码之间的调用，杜绝下层代码调用上层代码。所以，通用的代码我们尽量下沉到底层  

+ 继承、多态、封装、抽象  

  利用继承，可以将公共的代码抽取到父类，子类复用父类的属性和方法。利用多态，可以动态地替换一段代码的部分逻辑，让这段代码可复用。除此之外，抽象和封装，从更加广义的层面、而非侠义的面向对象特性的层面来理解的话，越抽象、越不依赖具体的实现，越容易复用。代码封装成模块，隐藏可变的细节、保罗不变的接口，越容易复用  
  
+ 应用模板等设计模式  
  
  一些设计模式，也能提高代码的复用性。比如，模板模式利用了多态来实现，可以灵活地替换其中的部分代码，整个流程模板代码可复用  
  
  
  
  
