### 什么是Spring Framework  

这个问题很难回答，每个人都会有每个人不同的理解  

整个Spring生态在涉及到java的项目开发中被广泛应用，提供了非常多的组件，能够让开发java应用的过程中更加容易，弹性地支持其他软件框架，给开发人员带来了非常多的遍历。Spring底层IOC容器设计的非常完美，在整个Spring应用上下文的生命周期和Spring Bean的生命周期的许多阶段提供了相应的扩展点，供开发者仔自行扩展，使得框架非常灵活  

### 对IoC的理解  

Inversion of Control（IoC）是面向对象中的一种编程思想或者原则。回到传统的方式，当依赖一个对象时，开发者需要做的是去创建这样一个对象并进行属性赋值，然后才能去使用这个对象。对于IoC这种方式来说，它使得对象或者组件的创建更为透明，不需要去过多地关注细节，如创建对象、属性赋值，这些工作都交给IoC容器来完成，达到解耦的目的  

IoC控制反转，简单来理解其实就是把获取依赖对象的方式，交由IoC容器来实现  

### 为什么需要IoC  

实际上，IoC是为了屏蔽构造细节。例如new出来的对象的生命周期中所有细节对于使用端来说都是知道的，如果在没有IoC容器的前提下，IoC是没有存在的必要的。不过在复杂的系统中，我们的应用更应该关注的是对象的运用而不是构造和初始化等细节  

### IoC和DI的区别  

DI依赖注入完全不同于IoC，更应该说DI依赖注入是IoC的一种实现方式或者策略  

依赖查找和依赖注入都是IoC的实现策略。依赖查找就是在应用程序里面主动调用IoC容器提供的接口去获取对应的Bean对象，而依赖注入是在IoC容器的启动或者初始化阶段，通过构造器、字段、setter方法或者接口等方式注入依赖。依赖查找相比于依赖注入对于开发者而言更为复杂，具有一定的代码侵入性，需要借助IoC容器提供的接口，所以我们总是强调后者。依赖注入在IoC容器中的实现也是调用相关的接口获取Bean对象，只不过这些工作都是在IoC容器启动时由容器帮助实现了，在应用程序中通常很少主动调用接口去获取Bean  

### IoC容器的职责  

主要有以下职责  

+ 依赖处理，通过依赖注入或者依赖查找  

+ 管理托管的资源（java Bean）的生命周期  

+ 管理配置（容器配置，外部化配置，托管的资源的配置）  

IoC容器其实有非常多，例如JDK的Java Beans，Java EE的EJB，Spring等，其中Spring是最成功的一个，目前被广泛应用  

### 什么是Spring容器  

Spring框架是一个IoC容器的实现，DI依赖注入是它的实现的一个原则，提供依赖查找和依赖注入两种依赖处理方式，管理着Bean的生命周期。Spring还提供了AOP抽象，事件抽象，事件监听机制，SPI机制，强大的第三方整合，易测试性等其他特性  

### 构造器注入和Setter注入  

构造器注入：通过构造器的参数注入相关依赖  

Setter注入：通过Setter方法注入依赖对下个，又可以理解为字段注入  

+ 构造器注入可以避免一些问题，例如状态被不确定性地修改，在初始化该对象时才会注入依赖对象，一定程度上保证了Bean初始化后就是不变的对象，这样对于程序和维护性都会带来更多的便利  
+ 构造器注入不允许出现循环依赖，因为它要求被注入的对象都是成熟态，保证能够实例化，而Setter注入没有这样的要求  
+ 构造器注入能够保证依赖的对象能够有序的被注入，而Sett注入底层是通过反射机制进行注入，无法完全保证注入的顺序性  

除了上面的注入，Spring还提供了接口回调注入，通过实现Aware接口（BeanNameAware、ApplicationContextAware）可以注入相关对象，Spring在初始化这类Bean时会调用其setXXX方法注入对象，例如注入beanName，ApplicationContext  

### BeanFactory和ApplicationContext谁才是Spring IoC容器  

BeanFactory是Spring底层IoC容器，ApplicationContext是BeanFactory的子接口，提供了IoC容器以外更多的功能，例如AOP面向切面，注解等。一般称ApplicationContext是Spring应用上下文，BeanFactory为Spring底层IoC容器  

### 什么是AOP  

AOP（Aspect-oriented Programming）面向切面编程，是一种开发理念，是OOP面向对象编程的补充。我们知道，Java就是一门面向对象的语言，在OOP中最小单元就是"class对象"，但是在AOP中最小的单元是"切面"。一个"切面"可以包含很多类型对象，对它们进行模块化管理，例如事务管理  

### 为什么要引入AOP  

Java OOP存在哪些局限性？  

+ 静态化语言，类结构一旦定义，不容易被修改  

+ 侵入性扩展：通过继承活组合组织新的类结构  

通过AOP我们可以把一些非业务逻辑的代码（比如安全检查、监控等代码）从业务中抽取出来，以非入侵的方式与原方法进行协同。这样可以使得原方法更专注于业务逻辑，代码接口更加清晰，便于维护  

### AOP使用的场景  

日志场景  

+ 诊断上下文，如：`log4j`或`logback`中的`_x0008_MDC`  

+ 辅助信息，如：方法执行的时间  

统计场景  

+ 方法调用次数

+ 执行异常次数  

+ 数据抽样

+ 数值累加  

安防场景  

+ 熔断，如：Netflix Hystrix  

+ 限流和降级，如：Alibaba Sentinel  

+ 认证和授权，如：Spring Security  

+ 监控，如：JMX  

性能场景  

+ 缓存，如：如Spring Cache  
+ 超时限制

### 什么是AOP代理  

代理模式是一种结构型设计模式，通过代理类为其他对象提供**一种代理以控制这个对象的访问**。AOP代理是AOP框架中AOP的实现，主要分为静态代理和动态代理，如下  

+ 静态代理：代理类需要实现被代理类所实现的接口，同时持有被代理类的引用，新增处理逻辑，进行拦截，不过方法还是由被代理类的引用所执行。静态代理通常需要有开发人员在编译阶段就定义好，不易于维护  

  + 常用OOP继承和组合结合  

  + AspectJ，在编辑阶段会织入Java字节码，qie在运行期间会进行增强  

+ 动态代理：不会修改字节码，而是在JVM内存根据目标对象新生成一个Class对象，这个对象包含了被代理对象的全部方法，并且在其中进行了增强  

  + JDK动态代理

  + 字节码提升，例如CGLIB  

