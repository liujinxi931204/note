## Springboot注解  
### @SpringBootApplication  
@SpringBootApplication注解时Spring Boot项目的基石，一般也不会主动使用它，创建Spring Boot项目之后会默认在主类上  
```java
@SpringBootApplication
public class SpringSecurityJwtGuideApplication {
      public static void main(java.lang.String[] args) {
        SpringApplication.run(SpringSecurityJwtGuideApplication.class, args);
    }
}
```  
可以将@SpringBootApplication这个注解看成是@Configuration、@EnableAutoConfiguratio、@ComponentScan注解的集合  
```java
package org.springframework.boot.autoconfigure;
@Target(ElementType.TYPE)
@Retention(RetentionPolicy.RUNTIME)
@Documented
@Inherited
@SpringBootConfiguration
@EnableAutoConfiguration
@ComponentScan(excludeFilters = {
		@Filter(type = FilterType.CUSTOM, classes = TypeExcludeFilter.class),
		@Filter(type = FilterType.CUSTOM, classes = AutoConfigurationExcludeFilter.class) })
public @interface SpringBootApplication {
   ......
}

package org.springframework.boot;
@Target(ElementType.TYPE)
@Retention(RetentionPolicy.RUNTIME)
@Documented
@Configuration
public @interface SpringBootConfiguration {

}
```  
这三个注解的作用分别是  
+ @EnableAutoConfiguration：启用SpringBoot的自动配置机制  
+ @ComponentScan：扫描被@Component、@Service、@Controller、@Repository注解的bean，注解默认会扫描该类所在的包及其子包  
+ @Configuration：允许在Spring上下文中注册额外的bean或导入其他的配置类。用来代替 applicationContext.xml 配置文件，所有这个配置文件里面能做到的事情都可以通过这个注解所在类来进行注册
### Spring Bean相关  
#### @AutoWired  
自动导入对象到类中，被注入进的类同样要被Spring容器管理。比如Service类注入到Controller中  
```java
@Service
public class UserService {
  ......
}

@RestController
@RequestMapping("/users")
public class UserController {
   @Autowired
   private UserService userService;
   ......
}
```
#### @Component，@Repository，@Service，@Controller  
一般使用@Autowired注解让Spring容器帮我们自动装配Bean。要想把类标识成可用于@Autowired注解自动装配的Bean类，可以采用以下注解实现  
+ @Component：通用的注解，可以标注任意类Spring组件。如果一个Bean不知道属于哪一层，可以使用@Component  
+ @Repository：对应持久层即Dao层，主要用于数据库相关操作  
+ @Service：对应服务层，主要涉及一些复杂的逻辑，需要用到Dao层  
+ @Controller：对应Spring MVC控制层，主要用于接收用户请求并调用Service层返回数据给前端页面  
#### @RestController  
@RestController注解是@Controller和@ReponseBody的合集，表示这是个控制器，并且将函数的返回值直接填写如Http响应体中，是REST风格的控制器  
单独使用@Controller不加@ResponseBody的话一般使用在要返回一个视图的情况，这种情况属于比较传统的Spring MVC的应用，对应于前后端不分离的情况。@Controller+@ResponseBody返回JSON或XML形式数据  
#### @Scope  
声明Spring Bean的作用域，使用方法  
```java
@Bean
@Scope("singleton")
public Person personSingleton() {
    return new Person();
}
```  
**四种常见的Spring Bean的作用域**  
+ singleton：唯一bean实例，Spring中的Bean 默认都是单例的  
+ prototype：每次请求都会创建一个新的Bean实例  
+ request：每一次Http请求都会产生一个新的Bean，该Bean仅在当前Http Request 内有效  
+ session：每一次Http请求都会产生一个新的Bean，该Bean仅在当前Http Session 内有效  
#### @Configuration  
一般用来声明配置类，可以使用@Component注解替代，不过使用@Configuration注解声明配置类更加语义化  
```java
@Configuration
public class AppConfig {
    @Bean
    public TransferService transferService() {
        return new TransferServiceImpl();
    }

}
```  
### 处理常见Http请求类型  
#### 5中常见的请求类型  
+ GET：请求从服务器获取特定的资源，例如 `GET /users`(获取所有用户信息)  
+ POST：在服务器上创建一个新的资源，例如 `POST /users`(创建用户)  
+ PUT：更新服务器上的资源(客户端提供更新后的整个资源)，例如`PUT /user/12`(更新编号为12的学生)  
+ DELETE：从服务器上删除特定的资源，例如`DELETE /user/12`(删除编号为12的学生)  
#### GET请求  
@GetMapping("/users")等价于@RequestMapping(value="/users",method=RequestMethod.GET)  
```java
@GetMapping("/users")
public ResponseEntity<List<User>> getAllUsers() {
    return userRepository.findAll();
}
```  
#### POST请求  
@PostMapping("/users")等价于@RequestMapping(value="/users",method=requestMethod.POST)  
```java
@PostMapping("/users")
public ResponseEntity<User> createUser(@Valid @RequestBody UserCreateRequest userCreateRequest) {
    return userRespository.save(user);
}
```
#### PUT请求  
@PutMapping("/user/{userid}")等价于@RequsetMapping(value="/user/{userid}",method=RequestMethod.PUT)  
```java
@PutMapping("/users/{userId}")
public ResponseEntity<User> updateUser(@PathVariable(value = "userId") Long userId,
  @Valid @RequestBody UserUpdateRequest userUpdateRequest) {
    ......
}
```
#### DELETE请求  
@DeleteMapping("/user/{userid}")等价于@RequestMapping(value="/user/{userid}",method=RequestMethod.DELETE)  
```java
@DeleteMapping("/users/{userId}")
public ResponseEntity deleteUser(@PathVariable(value = "userId") Long userId){
    ......
}
```
### 前后端传值  
#### @PathVariable和@RequestParam  
@PathVariable用于获取路径参数，@RequestParam用于获取查询参数  
例如  
```java
@GetMapping("/klasses/{klassId}/teachers")
public List<Teacher> getKlassRelatedTeachers(
         @PathVariable("klassId") Long klassId,
         @RequestParam(value = "type", required = false) String type ) {
    ...
}
```
如果请求的url是"/klasses/{123456}/teachers?type=web"  
那么这个函数获取到的数据就是 klassId=123456,type=web  
#### @RequestBody  
用于读取Reuqest请求(可能是POST、POST、DELETE、GET请求)的body部分并且Content-Type为application/json格式的数据，接收到数据之后会自动将数据绑定到java对象上去。系统会使用HttpMessageConverter或者自定义的HttpMessageConverter将请求中的body中的json字符串转化为java对象  
例如  
```java

```



















  

