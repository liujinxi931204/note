## redis支持的数据类型  
redis数据库支持五种数据类型  
1. 字符串(string)  
2. 哈希(hash)  
3. 列表(list)  
4. 集合(set)  
5. 有序集合(sorted set)  
### 字符串  
string是一组字节。在redis数据库中，字符串是二进制安全的。这意味它们具有已知的长度，并且不受任何特殊终止字符的影响。可以在一个字符串中存储最多512M字节的内容  
### 哈希  
哈希是键值对的集合。在redis中，哈希是字符串字段和字符串值之间的映射。因此，它们适合表示对象  
### 列表  
redis列表定义字符串列表，按插入顺序排序。可以将元素添加到redis列表的头部或者尾部  
### 集合  
集合(set)是redis数据库中的无序字符串集合。在redis中，添加、删除和查找的时间复杂度是O(1)  
### 有序集合  
redis有序集合类似于redis集合，也是一组非重复的字符串集合。但是，排序集合的每个成员都有一个分数与之相关联，该分数从最小到最高分数有序排序集。虽然成员是独特的，但是可以重复分数  
## redis命令  
redis命令用于在redis服务上执行操作。要在redis服务上执行命令需要一个redis客户端。在下载的redis安装包中  
### 语法  
启动客户端  
`redis-cli`  
该命令会连接本地的redis服务  
可以使用下面的命令检测redis服务是否启动  
```shell
redis-cli  
127.0.0.1:6379 >  
127.0.0.1:6379 > PING  
PONG  
```  
如果需要在远程redis服务上执行命令，同样使用redis-cli命令  
 
### 语法  
`redis-cli -h host -p port -a password`  
可以使用下面的命令检测远程的redis服务是否启动   
```shell
redis-cli -h host -p port -a "password"  
127.0.0.1:6379 >  
127.0.0.1:6379 > PING  
PONG  
```  
### 字符串  
字符串类型是redis最基础的数据结构。首先键都是字符串类型的，而且其他几种数据结构都是在字符串的基础之上构建的  
#### 常用命令    
1. 设置值  
`set key value [ ex seconds ] [px milliseconds ] [nx|xx]`  
时间复杂度O(1),将字符串值value关联到key，如果key已经持有其他值了，set旧覆写旧值，无视类型  
```shell
127.0.0.1:6379 > set hello world  
OK  
```   
上面这句用于设置键为hello，值为world的键值对，返回结果OK表示设置成功  
set命令有几个选项  
ex seconds: 为键设置秒级过期时间  
px milliseconds: 为键设置毫秒级过期时间  
nx: 键必须不存在，才可以设置成功，用于添加  
xx: 键必须存在，才可以设置成功，用于更新，正好与nx相反  
此外，redis还提供setex和setnx两个命令    
用法如下  
`setnx key value`  
时间复杂度O(1),只有在键key不存在的情况下才能将键key的值设置为value；如果key已经存在，则不做任何操作。命令在设置成功时返返回1，设置失败时返回0    
`setex key seconds value`  
时间复杂度O(1)，将键key的值设置为value，并将键key的生存时间设置为seconds秒。如果键key已经存在，那么setex命令将覆盖已有的值。命令在设置成功时返回OK；在seconds参数不合法时，命令将返回一个错误  
  
2. 获取值  
`get key`  
时间复杂度为O(1),返回与键key相关联的字符串值。如果键key不存在，那么返回特殊值nil；否则返回键key的值  
如果键key的值并非字符串类型，那么返回一个错误，因为gei命令只能用于字符串值  
```shell
127.0.0.1:6379 > get hello  
"world"  
127.0.0.1:6379 > get db  
(nil)
```  
  
3. 批量设置值  
`mset key value [key value ...]`  
时间复杂度O(n),	其中n为要被设置的键数 
`msetnx key value [key value ...]`  
时间复杂度为O(n),其中n为要被设置的键数  
mset与msetnx的区别在于  
**如果某个给定的键已经存在，mset将会使用新值覆盖旧值**
**如果某个给定的键已经存在，msetnx则会拒绝执行对所有键的设置操作**  
mset是一个原子性的操作，所有给定的键都会在同一时间内被设置，不会出现某些键被设置而另一些键没有被设置的情况；mset命令的返回值总是OK    
msetnx是一个原子性操作，所有给定的键要么同时被设置，要么全部不被设置，不会出现第三种状态；当给所有键设置成功时，返回值为1；如果因为某个键已经存在而导致未能设置成功，则返回0  
```shell
127.0.0.1:6379 > mset a 1 b 2 c 3 d 4  
OK
```
4. 批量获取  
`mget key [key ...]`  
时间复杂度为O(n),其中n为给定的键的数量。如果给定的字符串键里面有某个键不存在，那么这个键的值将以特殊值nil表示。  
结果是按照键传入顺序返回的     
```shell
127.0.0.1:6379 > mget a b c d  
1) "1"  
2) "2"  
3) "3"  
4) "4"  
```   
**注意：批量操作所发送的命令不是无节制的，如果数量过多可能会造成redis阻塞或者网络阻塞**  
  
5. 获取并设置  
`getset key value`  
时间复杂度为O(1),将键key的值设置为value，并将建key的旧值返回  
如果键key没有旧值，则返回nil;如果键key不是字符串类型时，则返回一个错误  
  
6. 计数  
`incr key`  
时间复杂度为O(1),为键key存储的数字值加1  
如果键key不存在，那么它的值会先被初始化为0，然后再执行incr命令,返回1；如果键存储的值是整数，返回自增后的结果；如果键存储的值不能被解释为数字，那么incr命令将会返回一个错误  
INCR命令是一个针对字符串的操作。因为redis并没有专用的整数类型，所以键key存储的值在执行incr命令时会被解释为十进制64位有符号整数  
  
`incrby key increment`  
时间复杂度为O(1)，为键key存储的数字值加上增量increment  
如果键key不存在，那么他的值会先被初始化位0，然后再执行incr命令，返回increment的值；如果键存储的值时整数，返回增加increment后的值；如果键key存储的值不能被解释位数字，那么该命令返回一个错误  
   
`decr key`  
时间复杂度O(1),为键key存储的数字值减1  
如果键key不存在，那么它的值会先被初始化为0，然后执行decr命令，返回-1；如果键key存储的值是整数，返回自减后的结果；如果存储的值不能被解释为数字，那么decr命令将会返回一个错误  
  
`decrby key decrement`  
时间复杂度为O(1),为键key存储的数字值减increment  
如果键key不存在，那么他的值会先被初始化为0，然后执行decrby命令，返回减法之后的结果；如果键key存储的是整数，返回执行减法操作之后的值；如果键key存储的值不能被解释为数值，那么decrby命令将会返回一个错误  
### 内部编码  
字符串类型的内部编码有3种：
1. int：8个字节的长整型  
2. embstr： 小于等于39个字节的字符串  
3. raw: 大于39个字节的字符串  
redis会根据当前值的类型和长度决定使用哪种内部编码实现  
### 哈希  
redis hash是一个string类型的field和value的映射表，hash特别适合用于存储对象，每个hash键中可以存储多达40亿个字段值  
![title](https://raw.githubusercontent.com/liujinxi931204/image/master/gitnote/2020/09/09/1599631827179-1599631827213.png)  
hash类型中的映射关系叫做field-value，注意这里的value是指field对应的值，不是键对应的值  
#### 常用命令  
1. 设置值  
`hset hash field value`  
时间复杂度为O(1)，将哈希表hash中域field的值设置为value。如果给定的哈希表不存在，那么会一个新的哈希表将被创建并执行hset操作；如果域field已经存在于哈希表中，那么它的旧值将被新值value覆盖  
当hset命令在哈希表中创建新的field域并成功为它设置值时，命令返回1；如果域field已经存在域哈希表中并且hset命令成功使用新值覆盖了它的旧值，那么命令返回0  
`hsetnx hash field value`  
时间复杂度为O(1)，当且仅当field尚未存在于哈希表的情况下，将它的值设置为value；如果给定域已经存在于哈希表中，那么将放弃执行设置操作；如果哈希表不存在，那么一个新的哈希表将被创建并执行hsetnx操作  
hsetnx命令在设置成功时返回1，在给定域已经存在而放弃执行设置操作返回0  
`hmset key field vlaue [ field value ...]`  
时间复杂度O(n),n为field-value对的数量，同时将多个field-value对设置到哈希表hash中，此命令会覆盖哈希表中已存在的域。如果key不存在，一个空哈希表被创建并执行mhset操作  
如果命令执行成功，返回"OK";当key不是哈希表类型时，返回一个错误  
2. 获取值  
`hget hash field`  
时间复杂度为O(1)，返回哈希表中给定域的值。hget命令在默认情况下返回给定域的值，如果给定域不存在于哈希表中，又或者给定的哈希表不存在，那么命令返回nil  
`hmget key field [ field ...]`  
时间复杂度为O(1)，返回哈希表中key中，一个或多个给定域的值。如果给定的域不存在域哈希表中，那么返回一个nil。因为不存在的哈希表key被当作一个空表来处理，所以对一个不存在的key进行hmget操作将返回一个只带有nil值的表  
`hgetall key`  
时间复杂度为O(n)，返回hash表中所有的域和值，在返回值里，紧跟在每个域名filed之后时域的值，所以返回值的长度是哈希表大小的两倍  
以列表的形式返回哈希表的域和域的值，若key不存在，返回空列表  
3. 删除field  
`hdel key field [ field ...]`  
时间复杂度为O(n)，n为要删除的域的数量，删除哈希表中的一个或多个指定域，不存在的域将被忽略。返回成功被移除的域的数量，不包括被忽略的域  
4. 返回域的数量  
`hlen key`  
时间复杂度O(1)，返回哈希表key中域的数量，当key不存在时返回0  
5. 域是否存在  
`hexixts hash field`  
时间复杂度为O(1)，检查给定域filed是否存在于哈希表hash中，



















 

  




 


