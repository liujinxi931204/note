## 客户端通信协议  
+ 客户端与服务端之间的通信协议是在TCP协议之上构建的  
+ redis制定了RESP(Redis Serialization Protocol,Redis序列化协议)实现客户端与服务端的正常交互，这种协议简单高效，既能够被机器解析，又容易被人类识别  
## 客户端API  
1. client list  
  
`client list`  
该命令能列出与redis服务端相连的所有客户端的连接信息  
![title](https://raw.githubusercontent.com/liujinxi931204/image/master/gitnote/2020/09/17/1600333275938-1600333275940.png)  
输出结果的每一行代表一个客户端的信息  
+ 标识:id、addr、fd、name  
这四个属性属于客户端的标识  
id: 客户端连接的唯一标识，这个id是随着redis的连接自增的，重启redis后会重置为0  
addr：客户端连接的ip和端口  
fd：socket的文件描述符，与lsof命令结果中的fd是同一个，如果fd=-1达标当前客户端不是外部客户端，而是redis内部的伪装客户端  
name：客户端的名字  
+ 输入缓冲区：qbuf、qubf-free  
redis为每个客户端分配了输入缓冲区，它的作用是将客户端发送的命令临时保存，同时redis会从输入缓冲区来去命令并执行，输入缓冲区为客户端发送命令到redis执行命令提供了缓冲功能  
qbuf和qbuf-free分别代表了这个缓冲区的总容量和剩余容量，redis没有提供相应的配置来规定每个缓冲区的大小，输入缓冲区会根据输入内容大小的不同动态的调整，只是要求每个客户端缓冲区的大小不能超过1G，超过后客户端会被关闭   
输入缓冲区过大主要是因为redis的处理速度跟不上输入缓冲区的输入速度，并且每次进入出入缓冲区的命令包含了大量bigkey，从而造成了输入缓冲器过大的情况。还有一种情况就是redis发生了阻塞，短期内不能处理命令，造成客户端输入的命令积压了输入缓冲区，造成了输入缓冲区过大  
1. 通过定期执行client list命令，收集qbuf和qbuf-free找到异常的连接记录并分析，最终找到可能出问题的客户端  
2. 通过info命令的info clients模块，找到最大的输入缓冲区  
![title](https://raw.githubusercontent.com/liujinxi931204/image/master/gitnote/2020/09/17/1600336573553-1600336573557.png)  
+ 输出缓冲区：obl、oll、omem  
redis为每个客户端分配了输出缓冲区，他的作用是保存命令执行的结果返回给客户端，为redis和客户端交互返回结果提供缓冲  
与输入缓冲区不同的是，输出缓冲区的容量可以通过参数client-output-buffer-limit来进行设置，并且输出缓冲区做的更加细致，按照客户端的不同，分为三种：普通客户端输出缓冲区、发布订阅客户端输出缓冲区、slave客户端输出缓冲区  
对应的配置规则是  
`client-output-buffer-limit <class> <hard limit> <soft limit> <soft seconds>`  
1. class 客户端类型：normal





