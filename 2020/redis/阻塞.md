redis是典型的单线程架构，所有的读写操作都是在一条主线程中完成的。当redis用于高并发场景时，这条线程就变成了它的生命线。导致阻塞问题的场景大致分为内在原因和外在原因  
+ 内在原因包括：不合理地使用API或数据结构、CPU饱和、持久化阻塞等  
+ 外在原因包括：CPU竞争、内存交换、网络问题等  
### 内在原因  
+ API或数据结构不合理  
+ CPU饱和的问题  
+ 持久化相关的阻塞  
#### API或数据结构不合理  
通常redis执行命令的速度非常快，但也存在例外，例如执行keys、sort、对一个包含上万个元素的hash结构执行hgetall命令等  
1. 如何发现慢查询  
redis原生提供慢查询统计功能，执行`slowlog get {n}`命令可以获取最近的n条慢查询命令，默认对于执行超过10毫秒的命令都会记录到一个定长的队列中，慢查询队列默认长度为128，实际中可以适当调大。慢查询本身只记录了命令执行时间，不包括网盟传输时间和命令队列时间，因此客户端发生阻塞异常，可能不是当前命令缓慢，而是在等待其他命令执行  
可以按照以下两个方向去调整：  
+ 修改高时间复杂度的命令，如hgetall改为hmget、禁止执行keys、sort等命令  
+ 调整大对象：缩减对象数据或把大对象拆分为多个小对象，防止以此命令