redis是典型的单线程架构，所有的读写操作都是在一条主线程中完成的。当redis用于高并发场景时，这条线程就变成了它的生命线。导致阻塞问题的场景大致分为内在原因和外在原因  
+ 内在原因包括：不合理地使用API或数据结构、CPU饱和、持久化阻塞等  
+ 外在原因包括：CPU竞争、内存交换、网络问题等  
### 内在原因  
+ API或数据结构不合理  
+ CPU饱和的问题  
+ 持久化相关的阻塞  
#### API或数据结构不合理  
通常redis执行命令的速度非常快，但也存在例外，例如执行keys、sort、对一个包含上万个元素的hash结构执行hgetall命令等  
1. 如何发现慢查询  
redis原生提供慢查询统计功能，执行`slowlog get {n}`命令可以获取最近的n条慢查询命令，默认对于执行超过10毫秒的命令都会记录到一个定长的队列中，慢查询队列默认长度为128，实际中可以适当调大。慢查询本身只记录了命令执行时间，不包括网盟传输时间和命令队列时间，因此客户端发生阻塞异常，可能不是当前命令缓慢，而是在等待其他命令执行  
可以按照以下两个方向去调整：  
+ 修改高时间复杂度的命令，如hgetall改为hmget、禁止执行keys、sort等命令  
+ 调整大对象：缩减对象数据或把大对象拆分为多个小对象，防止以此命令操作过多的诗剧  
2. 如何发现大对象  
redis本身提供发现大对象的工具，对应命令为`redis-cli -h {ip} -p {port} bigkeys` 内部原理采用分段进行scan操作，把历史扫描过的最大对象统计出来便于分析优化  
#### CPU饱和  
单线程的redis处理命令时只能使用一个CPU。而CPU饱和是指redis把单核CPU使用率跑到接近100%。对于这种情况，首先判断当前redis的并发量是否达到极限，建议使用统计命令redis-cli -h {ip} -p {port} --stat获取当前redis的使用情况  
#### 持久阻塞  
对于开启了持久化功能的redis节点，需要排查是否是持久化导致的阻塞。持久化引起主线程阻塞的操作主要有fork阻塞、AOF刷盘阻塞、HugePage写操作阻塞  
##### fork阻塞  
fork操作发生在RDB持久化和AOF重写时，redis主线程调用fork操作产生共享内存的子进程，由子进程完成持久化文件重写工作。如果


