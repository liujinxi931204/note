### 内存使用统计  
可以通过执行`info memory`命令获取内存相关指标  
需要重点关注的指标由：used_memory_rss、used_memory以及它们的比值mem_fragmentation_ratio  
当mem_fragmentation_ratio>1时，说明used_memory_rss-used_memory多出的部分并没有用于数据存储，而是被内存碎片所消耗，如果两者相差很大，说明碎片率很严重  
当mem_fragmentation_ratio<1时，这种情况一般出现在现在操作系统把redis内存交换(swap)到硬盘导致，出现这种情况时要格外关注，redis性能会变得很差，甚至僵死  
#### 内存消耗划分  
redis进程内存消耗主要包括：自身内存+对象内存+缓冲内存+内存碎片，其中redis空进程自身内存消耗非常少，通常used_memoey_rss在3MB左右，used_memory在800KB左右，一个空的redis进程消耗内存可以忽略不计  
![title](https://raw.githubusercontent.com/liujinxi931204/image/master/gitnote/2020/09/25/1601027457818-1601027457867.png)  
+ 对象内存  
对象内存时redis内存占用最大的一块，存储着用户所有的数据。对象内存的消耗可以理解为sizeof(key)+sizeof(values)。键对象都是字符串，在使用redis时很容易忽略键对内存消耗的影响，应当避免使用过长的键  
+ 缓冲内存  
缓冲内存主要包括：客户端缓冲区、复制积压缓冲区、AOF缓冲区  
客户端缓冲指的是所有接入redis服务器TCP连接的输入输出缓冲。输入缓冲区无法控制，最大为1G，超过将断开连接；输出缓冲通过参数client-outputbuffer-limit控制  
一般普通客户端的内存消耗可以忽略不计，但是当有大量慢连接客户端接入时这部分内存消耗就不能忽略了，可以设置max-client做限制  
主节点会为每一个从节点单独建立一条连接用于命令复制，当主从节点之间网络延迟较高或者主节点挂载大量从节点时这部分内存消耗将占用很大一部分，建议主节点挂载的从节点不要多余2个  
当使用发布订阅功能时，连接客户端使用单独的输出缓冲区，当订阅服务的消息产生快于消费速度时，输出缓冲区会积压
输入输出缓冲区在大流量场景中容易失控  
+ 复制积压缓冲区  
对于复制积压缓冲区整个主节点只有一个，所有的从节点共享此缓冲区，可以设置教的缓冲区空间，默认大小为1MB  
+ AOF缓冲区  
这部分空间用于在redis重写期间保存最近的写入命令。AOF缓冲区大小用户无法控制，消耗的内存取决于AOF重写时间和写入命令量  
#### 内存碎片  
redis默认的内存分配器采用jemalloc，可选的分配器还有glibc、tcmalloc。内存分配器为了更好地管理和重复利用内存，分配内存策略一般采用固定地内存块进行分配  
正常地碎片率(mem_fragmentation_ratio)在1.03左右  
+ 频繁更新操作  
+ 大量过期键删除，键对象过期删除后，释放的空间无法得到充分利用，导致碎片率上升  
出现高内存碎片问题时常见的解决方式如下：  
+ 数据对齐，在条件允许的情况下尽量做数据对齐，比如数据尽量采用数字类型或者固定长度字符串等  
+ 安全重启，重启节点可以做到内存碎片重新整理，因此可以利用高可用结构，如sentinel或cluste，将碎片率过高的主节点转换为从节点，进行安全重启  
#### 子进程内存消耗  
子进程内存消耗主要是指执行AOF\RDB重写时redis创建的子进程内存消耗。redis执行fork操作产生的子进程内存占用量对外表现与父进程相同，理论上需要一倍的物理内存来完成重写操作。但linux具有写时复制即使，父子进程会共享相同的物理内存页，当父进程处理写请求时会对需要修改的页复制出一份副本完成写操作，而子进程依然读取fork时整个父进程的内存快照  
虽然开启THP可以降低fork子进程的速度，但之后copy-on-write期间复制的内存页的单位从4KB变为2MB，如果父进程有大量写命令，会加重内存拷贝量，从而造成过度内存消耗  
+ 子进程内存消耗总结如下：  
1. redis产生的子进程并不需要消耗1倍的父进程内存，时机消耗根据期间写入命令量决定，但是依然要预留一些内存防止溢出  
2. 需要设置sysctl vm.overcommit_memory=1，允许内核分配所有的物理内存，防止redis进程执行fork时因系统剩余内存不足而失败  
3. 排查当前系统是否支持并开启THP，如果开启建议关闭，防止copy-on-write期间内存过度消耗  
#### 设置内存上限  
redis使用maxmemory参数限制最大可用内存，限制内存的目的主要有  
+ 用于缓存场景，当超出内存上限maxmemory时使用LRU等删除策略释放空间  
+ 防止所有内存超出服务器物理内存  
需要注意：maxmemory限制的是redis实际使用的内存量，也就是used_memory统计项对应的内存；`config get maxmemory`命令用户获取当前设置的内存上限，如果为0，表示不设置上限  
#### 动态调整内存上限  
redis的内存上限可以通过`config set maxmemory`进行动态修改  
### 内存回收策略  
#### 删除过期键对象  
redis所有的键都可以设置过期属性，内部保存在过期字典中。redis采用惰性删除和定时任务删除机制实现过期键的回收内存  
+ 惰性删除  
惰性删除用于当客户端读取带有超时属性的键时，如果已经过了键设置的过期时间，会执行删除操作并返回空。但是单独使用这种方式存在内存泄漏的问题，当过期键一直没有访问将无法得到及时删除，


