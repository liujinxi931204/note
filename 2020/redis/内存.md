### 内存使用统计  
可以通过执行`info memory`命令获取内存相关指标  
需要重点关注的指标由：used_memory_rss、used_memory以及它们的比值mem_fragmentation_ratio  
当mem_fragmentation_ratio>1时，说明used_memory_rss-used_memory多出的部分并没有用于数据存储，而是被内存碎片所消耗，如果两者相差很大，说明碎片率很严重  
当mem_fragmentation_ratio<1时，这种情况一般出现在现在操作系统把redis内存交换(swap)到硬盘导致，出现这种情况时要格外关注，redis性能会变得很差，甚至僵死  
#### 内存消耗划分  
redis进程内存消耗主要包括：自身内存+对象内存+缓冲内存+内存碎片，其中redis空进程自身内存消耗非常少，通常used_memoey_rss在3MB左右，used_memory在800KB左右，一个空的redis进程消耗内存可以忽略不计  
![title](https://gitee.com/liujinxi931204/image/raw/master/gitnote/2020/09/25/1601027457818-1601027457867.png)  

+ 对象内存  
对象内存时redis内存占用最大的一块，存储着用户所有的数据。对象内存的消耗可以理解为sizeof(key)+sizeof(values)。键对象都是字符串，在使用redis时很容易忽略键对内存消耗的影响，应当避免使用过长的键  
+ 缓冲内存  
缓冲内存主要包括：客户端缓冲区、复制积压缓冲区、AOF缓冲区  
客户端缓冲指的是所有接入redis服务器TCP连接的输入输出缓冲。输入缓冲区无法控制，最大为1G，超过将断开连接；输出缓冲通过参数client-outputbuffer-limit控制  
一般普通客户端的内存消耗可以忽略不计，但是当有大量慢连接客户端接入时这部分内存消耗就不能忽略了，可以设置max-client做限制  
主节点会为每一个从节点单独建立一条连接用于命令复制，当主从节点之间网络延迟较高或者主节点挂载大量从节点时这部分内存消耗将占用很大一部分，建议主节点挂载的从节点不要多余2个  
当使用发布订阅功能时，连接客户端使用单独的输出缓冲区，当订阅服务的消息产生快于消费速度时，输出缓冲区会积压
输入输出缓冲区在大流量场景中容易失控  
+ 复制积压缓冲区  
对于复制积压缓冲区整个主节点只有一个，所有的从节点共享此缓冲区，可以设置教的缓冲区空间，默认大小为1MB  
+ AOF缓冲区  
这部分空间用于在redis重写期间保存最近的写入命令。AOF缓冲区大小用户无法控制，消耗的内存取决于AOF重写时间和写入命令量  
#### 内存碎片  
redis默认的内存分配器采用jemalloc，可选的分配器还有glibc、tcmalloc。内存分配器为了更好地管理和重复利用内存，分配内存策略一般采用固定地内存块进行分配  
正常地碎片率(mem_fragmentation_ratio)在1.03左右  
+ 频繁更新操作  
+ 大量过期键删除，键对象过期删除后，释放的空间无法得到充分利用，导致碎片率上升  
出现高内存碎片问题时常见的解决方式如下：  
+ 数据对齐，在条件允许的情况下尽量做数据对齐，比如数据尽量采用数字类型或者固定长度字符串等  
+ 安全重启，重启节点可以做到内存碎片重新整理，因此可以利用高可用结构，如sentinel或cluste，将碎片率过高的主节点转换为从节点，进行安全重启  
#### 子进程内存消耗  
子进程内存消耗主要是指执行AOF\RDB重写时redis创建的子进程内存消耗。redis执行fork操作产生的子进程内存占用量对外表现与父进程相同，理论上需要一倍的物理内存来完成重写操作。但linux具有写时复制即使，父子进程会共享相同的物理内存页，当父进程处理写请求时会对需要修改的页复制出一份副本完成写操作，而子进程依然读取fork时整个父进程的内存快照  
虽然开启THP可以降低fork子进程的速度，但之后copy-on-write期间复制的内存页的单位从4KB变为2MB，如果父进程有大量写命令，会加重内存拷贝量，从而造成过度内存消耗  
+ 子进程内存消耗总结如下：  
1. redis产生的子进程并不需要消耗1倍的父进程内存，时机消耗根据期间写入命令量决定，但是依然要预留一些内存防止溢出  
2. 需要设置sysctl vm.overcommit_memory=1，允许内核分配所有的物理内存，防止redis进程执行fork时因系统剩余内存不足而失败  
3. 排查当前系统是否支持并开启THP，如果开启建议关闭，防止copy-on-write期间内存过度消耗  
#### 设置内存上限  
redis使用maxmemory参数限制最大可用内存，限制内存的目的主要有  
+ 用于缓存场景，当超出内存上限maxmemory时使用LRU等删除策略释放空间  
+ 防止所有内存超出服务器物理内存  
需要注意：maxmemory限制的是redis实际使用的内存量，也就是used_memory统计项对应的内存；`config get maxmemory`命令用户获取当前设置的内存上限，如果为0，表示不设置上限  
#### 动态调整内存上限  
redis的内存上限可以通过`config set maxmemory`进行动态修改  
### 内存回收策略  
#### 删除过期键对象  
redis所有的键都可以设置过期属性，内部保存在过期字典中。redis采用惰性删除和定时任务删除机制实现过期键的回收内存  
+ 惰性删除  
惰性删除用于当客户端读取带有超时属性的键时，如果已经过了键设置的过期时间，会执行删除操作并返回空。但是单独使用这种方式存在内存泄漏的问题，当过期键一直没有访问将无法得到及时删除，从而导致内存不能及时释放  
+ 定时任务删除  
redis内部维护一个定时任务，默认每秒运行10次。定时任务中删除过期键逻辑采用了自适应算法，根据键的过期比例、使用快慢两种速率模式回收键  
![title](https://gitee.com/liujinxi931204/image/raw/master/gitnote/2020/09/27/1601189825353-1601189825439.png)  
流程如下：  
1. redis配置项hz定义了serverCron任务的执行周期，默认为10，即CPU空闲时间每秒执行10次  
2. 每次过期key清理的时间不超过CPU时间的25%，即若hz=1，则一次清理时间最大为250ms，若hz=10，则一次清理时间最大为25ms  
3. 清理时遍历所有的db  
4. 从db中随机取20个key，判断是否过期，若过期则删除对应的键  
5. 如果超过检查数25%的键过期，则重复步骤四或者运行超时为止  
6. 如果之前回收键逻辑超时，则在redis触发内部事件之前再次以快模式运行回收过期键任务，快模式下超时时间为1毫秒且2秒内只能运行1次  
7. 快、慢模式内部删除逻辑相同，只是执行超时时间不同  
#### 内存溢出策略  
当redis所有内存达到maxmemory上限时会触发相应的溢出控制策略。具体策略受maxmemory-policy参数控制，redis支持6种策略    
+ noeviction：默认策略，不会删除任何数据，拒绝写入操作并返回客户端错误信息(OOM command not allowed when used memory),此时redis只响应读操作  
+ volatile-lru：根据LRU算法删除设置了超时属性(expire)的键，直到腾出足够的空间为止。如果没有可删除的键对象，回退到noevition策略  
+ allkeys-lru：根据LRU算法删除键，不管有没有设置超时属性，直到腾出足够的空间为止  
+ allkeys-random：随机删除所有键，直到腾出足够的空间为止  
+ volatile-random：随机删除过期键，直到腾出足够的空间为止  
+ volatile-ttl：根据键值对象的ttl属性，删除最近将要过期数据。如果没有，回退到noveiction策略  
内存溢出控制策略可以采用config set maxmemory-policy {policy}动态配置  
当redis因为内存溢出删除键时，可以通过`info stats`命令查看evicted_keys指标找出当前redis已经剔除的键的数量  
### 内存优化  
#### redisObject对象  
redis存储的所有值对象在内部定义为redisObject结构体  
![title](https://gitee.com/liujinxi931204/image/raw/master/gitnote/2020/09/27/1601192361370-1601192361373.png)  
redis存储的数据都使用redisObject来封装，下面针对每个字段做详细说明  
+ type字段：表示当前对象使用的数据类型，即string、hash、list、set、zset。可以使用`type {key}` 命令查看对象所属类型，type命令返回的是指对象类型，键都是string类型  
+ encoding字段：表示redis内部编码类型，encoding在redis内部使用，代表当前对象内部采用哪种数据结构实现  
+ lru字段：记录对象最后一次被访问的时间，当配置了maxmemory和maxmemory-policy=volatile-lru或allkeys-lru时，用于辅助LRU算法删除键数据。可以使用`object idletime {key}` 命令在不更新lru字段的情况下查看当前键的空闲时间  
+ recount字段：记录当前对象被引用的次数，用于通过引用次数回收内存，当recount=0时，可以安全回收对象空间。使用`object recount {key}`获取当前对象引用  
+ *ptr字段：与对象的数据类型内容相关。如果是整数，直接存储；否则表示指向数据的指针。redis在3.0之后对象值是字符串且长度<=39字节的数据，内部编码为embstr类型，字符串sds和redisObject一起分配，从而只要一次内存操作即可  
建议高并发写入场景中，在条件允许的情况下，建议字符串长度控制在39字节内，减少创建redisObject内存分配次数，从而提高性能  
#### 缩减键值对象  
降低redis内存使用最直接的方式就是缩减简直对象的长度  
#### 共享对象池  
共享对象池是指redis内部维护[0-9999]的整数对象池，当需要使用的0-9999的字符串对象时会引用这些共享对象。除了整数值对象外，其他类型如list、hash、set、zset内部元素也可以使用整数对象池  
整数对象池在redis中通过变量REDIS_SHARED_INTERGERS定义，不能通过配置修改，可以通过`object refcount`命令查看对象引用数，验证是否启用整数对象连接池技术  
maxmemory+LRU策略与共享对象池冲突。这时因为LRU算法需要获取对象最后被访问的时间，以便淘汰最长未访问数据，每个对象最后访问时间存储在redisObject对象的lru字段。对象共享意味着多个引用共享同一个redisObject，这时lru字段也会被共享，导致无法获取每个对象的最后访问时间。如果没有设置maxmemory，直到内存耗尽redis也不会触发内存回收，所以共享对象池可以正常工作  
对于ziplist编码的对象，及时内部数据为整数页无法使用共享对象池，因此ziplist使用压缩且连内存的结构，对象共享判断成本过高  
#### 字符串优化  
字符串对象是redis内部最常用的数据类型，所有的键都是字符串类型，值对象除了整数之外都是使用字符串存储  
redis没有采用原生C语言的字符串类型而是自己实现了字符串结构，内部简单动态字符串(simple dynamic string，SDS)  
![title](https://gitee.com/liujinxi931204/image/raw/master/gitnote/2020/09/27/1601197617386-1601197617388.png)  
redis自身实现的字符串结构有如下特点：  
+ O(1)时间复杂度：字符串长度、已用长度、未用长度  
+ 可用于保存字节数组，支持安全的二进制数据存储  
+ 内部实现空间预分配机制，降低内存再次分配次数  
+ 惰性删除机制，字符串缩减后的空间不释放，作为预分配空间保留  
空间预分配规则如下：  
1. 第一次创建，len属性等于实际数据大小，free等于0，不做预分配  
2. 修改后如果已有free空间不够且数据小于1M，每次预分配一倍容量。如原有len=60byte，free=0，再追加60byte，预分配120byte，总占用空间为：60byte+60byte+120byte+1byte  
3. 修改后如果已有free空间不够且数据大于1M，每次预分配1MB数据。如原有len=30MB，free=0，再追加100byte，预分配1MB，总占用空间为：30MB+100byte+1MB+1byte  
尽量减少字符串频繁修改操作如append、setrange，改为直接使用set修改字符串，降低预分配带来的内存浪费和内存碎化比  
#### 编码优化  
redis对外提供了string、list、hash、set、zet等类型，但是redis内部针对不同类型存在编码的概念。使用`object encoding {key}`命令获取编码类型  
redis针对每种数据类型(type)，可以采用至少两种编码方式来实现  
![title](https://gitee.com/liujinxi931204/image/raw/master/gitnote/2020/10/09/1602212601751-1602212601837.png)  
编码类型转换在redis写入数据时自动完成，这个转换过程是不可逆的，转换规则只能从小内存编码向大内存编码转换  
![title](https://gitee.com/liujinxi931204/image/raw/master/gitnote/2020/10/09/1602214209767-1602214209768.png)  
对于已经采用非压缩编码类型的数据如hashtable、linkedlist等，设置参数后即使数据满足压缩条件，redis也不会做转换，需要重启redis重新加载数据才能完成转换  
##### ziplist  
ziplist编码主要目的是为了节约内存，因此所有数据都是采用线性连续的内存结构。ziplist编码是应用范围最广的一种，可以分别作为hash、list、zset类型的底层数据结构实现  
一个ziplist可以包含多个entry(元素),每个entry保存具体的数据(整数或字节数组)  
![title](https://gitee.com/liujinxi931204/image/raw/master/gitnote/2020/10/09/1602214797438-1602214797440.png)  
ziplist结构字段含义  
1. zlbytes：记录整个压缩列表所占字节长度，方便重新调整ziplist空间，类型是int-32，长度是4字节  
2. zltail：记录距离尾节点的偏移量，方便尾节点弹出操作，类型是int-32，长度是4字节  
3. zllen：记录压缩列表节点数量，当长度超过216-2时需要遍历整个列表获取长度，一般很少见，类型是int-16，长度是2字节  
4. entry：记录具体的节点，长度根据实际存储的数据而定  
+ pre_entry_bytes_length:记录前一个节点所占空间，用于快速定位上一个节点，可实现列表反向迭代  
+ encoding：标示当前节点编码和长度，前两位表示编码类型：字符串\整数,其余位标识数据长度  
+ contents：保存节点的指，针对实际数据长度做内存占用优化  
5. zlend：记录列表结尾，占用一个字节  
ziplist压缩编码的性能表现跟值长度和元素个数密切相关，正因为如此redis提供了{type}-max-ziplist-value和{type}-max-ziplist-entries相关参数来做控制ziplist编码转换。使用ziplist压缩编码应该追求空间和时间的平衡  
针对性能要求较高的场景使用ziplist，建议长度不要超过1000，每个元素大小控制在512字节内  
##### intset编码  
intset编码是集合(set)类型编码的一种，内部表现为存储有序、不重复的整数集。当集合只包含整数且长度不超过set-max-intset-entries配置时被启用  
![title](https://gitee.com/liujinxi931204/image/raw/master/gitnote/2020/10/09/1602228089242-1602228089243.png)  
intset的字段结构含义：  
1. encoding：整数表示类型，根据集合内最长整数值确定类型，整数类型划分为三种：int-16、int-32、int-64  
2. length：表示集合元素个数  
3. contents：整数数组，按从小到大顺序保存  
intset保存的整数类型根据长度划分，当保存的整数超出当前类型时，将会触发自动升级操作且升级后不再回退。升级操作将会导致重新申请内存空间，把原有数据按转换类型后拷贝到新数组  
使用intset编码的集合时，尽量保持整数范围一致，防止大整数触发集合升级操作，产生内存浪费  
#### 控制键的数量  
当使用redis存储大量数据时，通常会存在大量键，过多的键同样会消耗大量内存  
对于存储相同的数据内容利用redis的数据结构降低外层键的数量，也可以节省大量内存  
使用hash重构后内存节省效果非常明显，特别对于存储小对象的场景，内存只有不到原来的1/5  
+ hash类型节省内存的原理是使用ziplist编码，如果使用hashtable编码方式反而会增加内存消耗  
+ ziplist长度需要控制在1000以内，长列表会导致CPU消耗严重  
+ ziplist适合存储小对象，对于大对象不但内存优化效果不明显还会增加命令操作耗时  
+ 需要预估键的规模，从而确定每个hash结构需要存储的元素数量  
+ 根据hash长度和元素大小，调整hash-max-ziplist-entries和hash-max-ziplist-value参数，确保hash类型使用ziplist编码  
**hash重构后所有的键再也无法使用超时(expire)和LRU淘汰机制自动删除，需要手动维护删除**  























