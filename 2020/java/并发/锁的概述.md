### 乐观锁与悲观锁  

悲观锁指对数据被外界修改持保守态度，认为数据很容易被其他线程修改，所以在数据处理之前先对数据进行加锁，并在整个数据处理过程中，使数据处于锁定状态。  

乐观锁是相对于悲观锁来说的，它认为数据在一般情况下不会造成冲突，所以在访问记录前不会加排他锁，而是在进行数据提交更新时，才会正式对数据冲突与否进行检测。  

### 公平锁与非公平锁  

根据线程获取锁的抢占机制，锁可以分为公平锁和非公平锁。公平锁表示线程获取锁的顺序是按照线程请求锁的时间早晚来决定的，也就是最早请求锁的线程将最早获取到锁。而非公平锁则在运行时闯入，也就是先来的线程不一定先得到锁。  

ReentrantLock 提供了公平锁和非公平锁的实现  

```java
//公平锁  
ReentrantLock lock = new ReentrantLock(true);
//非公平锁
ReentrantLock lock = new ReentrantLock(false);
```

如果构造函数不传参数，默认是非公平锁。  

### 独占锁与共享锁  

根据锁能够被单个线程持有还是多个线程持有，锁可以分为独占锁和共享锁。  

独占锁保证任何时候只有一个线程能够得到锁，ReentrantLock就是独占的方式实现的。共享锁则可以同时由多个线程持有，例如ReadWriteLock读写锁，它允许一个资源可以被多个线程同时进行读操作。  

独占锁是一种悲观锁，由于每次访问资源都先加上互斥锁，这限制了并发性，因为读操作不会影响数据的一致性，而独占锁只允许在同一时间有一个线程读取数据，其他线程必须等待当前线程释放锁才可以进行读取。  

共享锁是一种乐观锁，它放宽了加锁的条件，允许多个线程同时进行读操作。  

```java
ReadWriteLock rwlock = new ReentrantReadWriteLock();
//共享读锁
Lock rlock = rwlock.readLock();
//独占写锁
Lock wlock = rwlock.writeLock();
```

### 可重入锁  

当一个线程获取一个被其他线程持有的独占锁时，该线程会被阻塞。而当一个线程再次获取被本线程持有的锁时，可以再次获取锁而不会死锁。  

### 自旋锁  

由于java线程是与操作系统线程一一对应的，所以当一个线程获取锁失败后，会被切换到内核态而挂起。当该线程获得锁的时候又需要将其切换到内核态而唤醒该线程。而从用户态切换到内核态的开销是比较大的（因为需要变量传递、上下文保存等），在一定程度上影响并发性能。自旋锁则是，当前线程在获得锁时，如果发现锁已经被其他的线程占有，它不马上阻塞自己，在不放弃cpu使用权的情况下，多次尝试获取（默认次数是10次），很有可能在后面几次尝试中其他线程已经释放了锁。如果尝试指定的次数后仍没有获取到锁则当前线程才会被挂起。由此看来自旋锁是使用cpu时间换取线程阻塞与调度的开销，但是很有可能这些cpu时间被白白浪费。