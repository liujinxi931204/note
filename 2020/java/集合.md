## Java集合   
Java集合就像一种容器，可以动态的把多个对象的引用放入容器中  
Java集合类用于存储数量不等的多个对象，还可以用于保存具有映射关系的关联数组  
Java集合可以分为Collection和Map两种体系：  
+ Collection接口：单列数据，定义了存取一组对象的方法的集合  
  1. List：元素有序，可重复的集合  
  2. Set：元素无序，不可重复的集合  
+ Map接口：双列数据，保存具有映射关系"key-value对"的集合  
**一般需要重写equals()和hashCode()这两个方法**  
### Collection接口继承树  
![title](https://raw.githubusercontent.com/liujinxi931204/image/master/gitnote/2020/10/30/1604067881236-1604067881244.png)   
### Map接口继承树  
![title](https://raw.githubusercontent.com/liujinxi931204/image/master/gitnote/2020/10/30/1604067906211-1604067906216.png)  
### Collection接口中的方法的使用  
1. 添加  
+ add(E e)  
+ addAll(E e)
2. 获取有效元素的个数  
+ size()  
3. 清空集合  
+ clear()
4. 是否空集合  
+ isEmpty()
5. 是否包含某个元素  
+ contains(E e)  通过元素的equals方法来判断是否是同一个元素  
+ containsAll(Collection coll)  通过元素的equals方法来挨个比较两个集合中元素是否是同一个元素  
6. 删除  
+ remove(E e) 通过元素的equals方法来判断是否是要删除的哪个元素，只会删除找到的第一个元素  
+ removeAll(Collection coll) 取当前集合的差集  
7. 取两个集合的交集  
+ retainAll(Collection coll) 取两个集合的交集  
8. 集合是否相等  
+ equals(E e)  
9. 转化成对象数组  
+ toArray()  
10. 获取集合对象的哈希值  
+ hashCode()  
11. 遍历  
+ iterator() 返回迭代器对象，用于集合遍历  
12. 交集  
+ retianAll(Collection coll) 用于获取两个集合的交集，返回给当前集合，相当于是修改了当前的集合  
13. 数组转化为List  
asList(Object[] objs)  将数组objs转换为List，对于int等基本类型的数组，需要使用对应的包装类来生成对应的数组  
### 迭代器Iterator  
Collection接口继承了java.lang.Iterable接口，该接口有一个iterator()方法，那么所有实现了Collection接口的集合类都有一个iterator()方法，用以返回一个实现了Iterable接口的对象  
Iterator仅用于遍历集合，Itertor本身并不提供继承对象的能力，如果需要创建iterator对象，则必须有一个被迭代的集合  
集合对象每次调用iterator()方法得到一个全新的迭代器对象，默认游标都在集合的第一个元素之前  
#### Iterator的方法  
1. 获取下一位的元素    
next()  
2. 是否存在下一个元素  
hashNext()  
3. 删除某一个元素  
remove()  
  
**在调用next()方法之前必须要先调用hashNext()判断下一个元素是否有效。若不调用，且下一条记录无效，next()方法会抛出一个NoSuchElementException异常**  
  
**每一次调用iterator()方法时都会返回一个新的迭代器，位置在第一个元素之前的位置**  
  
**当使用iterator对集合元素进行迭代时，iterator并不是把集合元素本身传递给了迭代变量，而是把集合元素的值传递给了迭代变量，所以修改迭代变量的值对集合元素本身没有影响。增强for循环本身就是使用iterator，所以修改迭代变量同样不会修改元素的本身**  

### List接口  
LIst集合中的元素有序、且可重复，集合中的每个元素都有其对应的顺序索引  
List容器中的元素都对应一个整数型的需要记载其在容器中的位置，可以根据序号存取容器中的元素  
JDK API中list接口的实现类常用的由ArrayList、LinkedList和Vector  
+ ArrayList 作为List接口的主要实现类，线程不安全，效率比较高，底层使用Object[] elementData数组存储，主要适合查询操作  
+ LinkedList 底层使用双向链表存储，对于频繁的插入、删除操作，效率比ArrayList高  
+ 尽量返回接口而非实际的类型，如返回List而非返回ArrayList,这样如果以后需要将ArrayList转换成LinkedLisk时，客户端不用改变代码，这就是针对抽象编程  
+ 使用set去重的时候，使用HashSet去重，无法保证元素的原有顺序，使用LinkedHashSet可以保证元素的原有顺序  
#### List接口中常用的方法  
+ 添加  
1. add(E e): 向列表尾部添加指定的元素  
2. add(E e,int index)：向列表指定位置添加指定元素  
3. addAll(List list): 追加指定List中的所有元素到此列表中  
+ 查询  
1. get(int index)：获取指定位置的元素  
2. hashCode(): 返回列表的哈希值  
3. indexOf(E e): 查询元素e第一次出现的索引值  
4. lastIndexOf(E e): 查询元素e最后一次出现的索引值  
+ 删除  
1. remove(E e): 删除元素e  
2. removeAll(): 删除所有元素  
+ 更新  
1. set(int index ,E e): 将索引为index的元素值更新为e  
+ 判空  
1 isEmpty(): 判断列表是否为空  
+ 元素个数  
1. size(): 返回列表的元素的数量    
+ 子列表  
1. subList(int startIndex,int endIndex): 返回只当startIndex(包括)和endIndex(不包括)之间的部分列表  
**所有的List中可以有null元素**  
#### List的两种排序方法  
##### 实现comparator接口  
**利用Collections类的java.util.Collections.sort(java.util.List,java.util.Comparator)方法，自定义比较器对象对指定对象进行排序**  
实现User类  
```java
public class User {

    private String name;
    private int age;

    public User(String name, int age) {
        this.name = name;
        this.age = age;
    }

    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;

        User user = (User) o;

        if (age != user.age) return false;
        return name != null ? name.equals(user.name) : user.name == null;
    }

    @Override
    public int hashCode() {
        int result = name != null ? name.hashCode() : 0;
        result = 31 * result + age;
        return result;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public int getAge() {
        return age;
    }

    public void setAge(int age) {
        this.age = age;
    }
}

```  
实现Comparator接口的userComparator类  
```java
import java.util.Comparator;

public class userComparator implements Comparator<User> {

    @Override
    public int compare(User user1, User user2) {
        int flag=user1.getName().compareTo(user2.getName());
        if(flag==0){
            return user1.getAge()-user2.getAge();
        }else {
            return flag;
        }
    }
}

```  
测试类  
```java
public class userTest{
    @Test
    public void testSort(){
    
    User user1=new User("aa",13);
    User user2=new User("bb",12);
    User user3=new User("aa",11);

    List<User> userList=new ArrayList<>();
    userList.add(user1);
    userList.add(user2);
    userList.add(user3);
    
    Collestions.sort(userList,new userComparator());
    
    for(User user:userList){
            System.out.println(user);
        }
    }
}
```   
##### 通过实现Comparable接口来实现list的排序  
**使用这种排序方式，需要实现类实现Comparable接口，重写CompareTo()方法即可，不需要像实现Comparator接口那样，在类的外部单独实现**  
实现User类  
```java
public class User implements Comparable {

    private String name;
    private int age;

    public User(String name, int age) {
        this.name = name;
        this.age = age;
    }
    @Override
    public int CompareTo(User user) {
        return this.getAge().CompareTo(user.getAge());
    }
    

    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;

        User user = (User) o;

        if (age != user.age) return false;
        return name != null ? name.equals(user.name) : user.name == null;
    }

    @Override
    public int hashCode() {
        int result = name != null ? name.hashCode() : 0;
        result = 31 * result + age;
        return result;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public int getAge() {
        return age;
    }

    public void setAge(int age) {
        this.age = age;
    }
}
```   
测试类  
```java
public class userTest{
    @Test
    public void testSort(){
    
    User user1=new User("aa",13);
    User user2=new User("bb",12);
    User user3=new User("aa",11);

    List<User> userList=new ArrayList<>();
    userList.add(user1);
    userList.add(user2);
    userList.add(user3);
    
    Collestions.sort(userList);
    
    for(User user:userList){
            System.out.println(user);
        }
    }
}
```  
**实现Comparable接口的方式是自己完成比较，实现Comparator接口的方式则是在外部完成比较**  
### ArrayList类  
#### 基本语法  
+ ArrayList()：构造一个容量为10的空列表(每次递增容量的一半)  
+ ArrayList(Collectioin<? extends E> coll)：构造一个包含指定collection的元素的列表，元素的顺序是按照collection的迭代器返回的顺序排列的    
+ ArrayList(int initiaCapacity)：构造一个具有指定初始容量的空列表  

**ArrayList依赖于数组实现的，当new 一个ArrayList的时候，ArrayList会并不会真的创建一个长度为10的数组，而当调用add()方法的时候会创建一个长度为10的Object[]数组，扩容的时候长度变为原来的1.5倍，并且将新增的元素复制到新的列表中**  
### LinkedList  
#### 基本语法  
+ 获取元素  
1. getFirst():返回列表的第一个元素  
2. getLast():返回列表的最后一个元素  
+ 删除元素  
1. removeFirst():删除第一个元素并返回  
2. removeLast():删除最后一个元素并返回  
3. removeFirstOccurence(Object o)：从此列表中删除第一次出现的指定元素  
4. removeLastOccurence(Object o):从此列表中删除最后一次出现的指定元素    
  
**LinkedList在执行new LinkedList<>()的时候并不会真的创建一个双向链表，而当执行add等操作时，回创建一个包含pre、next两个指针的node节点，然后添加元素，每次add操作都会执行同样的操作**  
### set接口  
set体系结构可以知道某个对象是否已经存在于集合中，不会存储重复的元素。加入set的每个元素必须时唯一的。要想加进set体系，对象类必须实现equals()，这样才能标明对象的唯一性。set接口不保证会用哪种顺序来存储元素  
#### 继承的子类  
+ HashSet:为快速查找设计的set，存入HashSet的对象必须实现了hashCode()方法  
+ TreeSet：保存次序的set，使用它可以从set中提取有序的序列  
+ LinkedHashSet：

  





  





 


