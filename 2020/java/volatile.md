volatile可以看作是轻量级的synchornized，它只保证共享变量的可见性。在线程A修改被volatile修饰的变量后，线程B能够读取到正确的值。java在多线程中操作共享变量的过程中，会存在指定重排序与共享变量工作内存缓存的问题  
## java内存模型  
![title](https://raw.githubusercontent.com/liujinxi931204/image/master/gitnote/2020/12/20/1608435333675-1608435333684.png)  
java内存模型规定了所有的变量都存储在主内存中。每条线程还有自己的工作内存，线程的工作内存中保存了被该线程所使用到的变量(这些变量是从主内存中拷贝出来的)。线程对变量的所有操作(读取、赋值)都必须在工作内存中进行。不同线程之间也无法直接访问对方工作内存中的变量，线程间变量值得传递均需要通过主内存来完成  
## 并发编程的三大概念  
### 可见性  
可见性，是指线程之间的可见性，一个线程修改的状态对另一个线程是可见的。也就是线程修改的结果另一个线程马上就能看到。比如：用volatile修饰的变量，就会具有可见性。volatile修饰的变量**不允许线程内部缓存和重排序，即直接修改内存**，所以对其他线程是可见的。但是需要注意：**volatile只能让它修饰的内容具有可见性，但不能保证它具有原子性**。例如：  
```java
//保证变量a具有可见性
volatile int a=0;
//但是不能保证a++具有原子性
a++;
```
这个变量a具有可见性，但是a++依然是一个非原子操作，也就是说这个操作同样存在线程安全问题  
而普通的共享变量不能保证可见性，因为普通共享变量被修改以后，什么时候写入主内存是不确定的，而当其他线程去读取时，此时主内存中的变量值可能还是原来的旧值，因此无法保证可见性  
在java中synchornized和Lock也能够保证可见性，synchornized和Lock能保证同一时刻只有一个线程获取锁然后执行同步代码，并且在释放锁之前将对变量的修改刷新到主内存当中，因此可以保证可见性  
### 原子性  
即一个操作或者多个操作要么全部执行并且执行的过程中不会被任何因素打断，要么就都不执行。在java中，对基本数据类型的变量的读取和赋值操作是原子性操作，即这些操作是不可被中断的，要么执行要么不执行  
比如a=0;(a非long和double类型)这个操作是不可分割的；再比如a++；这个操作实际上是a=a+1;是可分割的，所以这不是一个原子操作。非原子操作都会存在线程安全的问题，需要使用同步技术让它变成一个原子操作。java的concurrent包下提供了一些原子类，比如AtomicInteger、AtomicLong等  
java内存模型只能保证基本读取和赋值操作是原子操作，如果要实现更大范围操作的原子性，可以通过synchornized和Lock来实现  
### 有序性  
有序性就是程序执行的顺序按照代码的先后顺序执行  
什么是指令重排序，一般来说，处理器为了提高程序运行效率，可能会对输入代码进行优化，它不保证程序中各个语句的执行先后顺序同代码中的顺序一致，但是它会保证最终执行结果和代码顺序的结果是一致的。指令重排序不会影响单个线程的执行，但是会影响到线程并发执行的正确性  
在java中，可以通过volatile关键字来保证一定的"有序性"。另外可以通过synchornized和Lock来保证有序性，很显然，synchornized和Lock可以保证每个时刻是
















