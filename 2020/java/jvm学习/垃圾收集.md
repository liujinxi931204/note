垃圾收回又称为GC（Garbage Collection），关于GC有三件事需要了解  

+ 哪些内存需要回收

+ 什么时候回收

+ 如何回收

## 哪些内存需要回收  

众所周知，java的内存区域分为五大部分：程序计数器、虚拟机栈、本地方法栈、堆和方法区。其中程序计数器、虚拟机栈和本地方法栈是线程私有的，跟随线程的创建而创建，随着线程销毁而销毁，因此这几个内存区域的分配和回收都是确定的，当方法或者线程结束的时候自然就会被回收了。而堆和方法区这两个区域有很显著的不确定性，这部分内存的分配和回收都是动态的，正是垃圾收集器需要关注的部分  

## 什么时候回收  

垃圾回收需要回收那些已经"死亡"的对象，也就是说这些对象不会再被使用了。如何判断一个对象不会再被使用呢？主要有两种方法：一种是引用计数算法，一种是可达性分析算法  

### 引用计数算法  

在对象中添加一个引用计数器，每当有一个地方引用它时，计时器的值就加一；当引用失效时，计数器的值减一；任何时刻计数器的值为零时，说明这个对象是不可再被使用的。此时这个对象可以作为垃圾被回收。

优点：原理简单，判断效率也很高

缺点：单纯的引用计数算法无法解决对象之间相互循环应用的问题  

![循环引用](https://gitee.com/liujinxi931204/typoraImage/raw/master/img/%E5%BE%AA%E7%8E%AF%E5%BC%95%E7%94%A8.png)  

### 可达性分析算法  

java语言使用的是可达性分析算法来判断对象是否存活的。这个算法的思路就是通过一系列称为"GC Roots"的根对象起点作为起始点集，从这些点开始，根据引用关系向下搜索，搜索过程所走过的路径称为"引用链"，如果某个对象到GC Roots间没有任何引用链相连，或者用图论的话来说从GC Roots到这个对象不可达，则证明此对象是不可能再被使用的  

  ![可达性分析算法](https://gitee.com/liujinxi931204/typoraImage/raw/master/img/%E5%8F%AF%E8%BE%BE%E6%80%A7%E5%88%86%E6%9E%90%E7%AE%97%E6%B3%95.png)

可达性分析算法可以解决相互引用的问题，如果从GC Roots不能到达这两个对象，那么即使这两个对象相互之间循环引用也是可以被判断为可以回收的对象的  

固定可以作为GC Roots的对象包括以下几种  

+ 在虚拟机栈中（栈帧中的本地变量表）中引用的对象，例如栈帧中的参数、局部变量、临时变量等  

+ 在方法区中类静态属性引用的对象，例如类中的引用类型静态变量  

+ 在方法区中常量引用的对象，例如字符串常量池里的引用  

+ 本地方法栈中引用的对象  

+ 虚拟机内部的引用，如基本数据类型对应的Class对象，一些常驻的异常对象（OutOfMemoryError），还有系统类加载器  

+ 所有被同步锁（synchornized关键字）持有的对象

+ 反映java虚拟机内部情况的JMX Bean、JVMTI中注册的回调、本地代码缓存等

除了这些固定的GC Roots之外，根据用户所选用的垃圾收集器以及当前垃圾回收的内存区域不同，还可以临时性的加入其他对象作为GC Roots，共同构成完整的GC Roots集合。

那么可达性分析算法判定为不可达的对象就真的一定会被回收吗？答案是否定的。要真正的宣告一个对象的死亡至少要经历两次标记的过程：如果对象在可达性分析后发现没有与GC Roots相连接，那么它将会第一次标记，随后进行一次筛选，筛选的条件是此对象是否有必要执行finalize()方法。假如对象没有覆盖finalize()方法，或者finalize()方法已经被虚拟机调用过，那么虚拟机将这两种情况都视为"没有必要执行"，此时虚拟机会判定对象已经死亡可以进行回收 

如果这个对象被判定为确有必要执行finalize()方法，那么该对象会被放置到一个名为F-Queue的队列之中，并在稍后由一条由虚拟机自动建立的、低调度优先级的Finalizer线程去执行它们的finalize方法。但是虚拟机不保证一定会等待finalize方法执行完毕，这是因为如果某个对象的finalize方法执行缓慢或者发生了死循环，将很可能导致F-Queue队列中的其他对象永久处于等待状态，甚至导致整个内存回收子系统的崩溃。finalize()方法是对象逃脱死亡命运的最后一次机会，稍后收集器将对F-Queue中的对象进行第二次小规模的标记，如果对象要在finalize()中成功拯救自己——只要重新与引用链上的任何一个对象建立关联即可，譬如把自己 （this关键字）赋值给某个类变量或者对象的成员变量，那在第二次标记时它将被移出“即将回收”的集 合；如果对象这时候还没有逃脱，那基本上它就真的要被回收了。

**对象的finalize()方法只会被JVM执行一次，如果进行二次GC再次触发了该对象回收就不会再执行了，直接会回收掉。并不鼓励使用finalize()方法，它运行代价高昂，不确定性大，无法保证各个对象的调用顺序**  

**从java9开始，finalize方法已经被标记为deprecated** 

下面有一个例子来演示对象的自我拯救  

```java
package test.vm;

public class FinalizeEscapeGC {
    public static FinalizeEscapeGC SAVE_HOOK;

    @Override
    protected void finalize() throws Throwable {
        super.finalize();
        System.out.println("finalize method executed!");
        FinalizeEscapeGC.SAVE_HOOK = this;
    }

    public static void main(String[] args) throws InterruptedException {
        SAVE_HOOK = new FinalizeEscapeGC();
        SAVE_HOOK = null;
        System.gc();

        //由于finalize方法执行优先级很低，所以需要暂停0.5秒等待它执行
        Thread.sleep(500);
        if (SAVE_HOOK != null){
            System.out.println("I'am still alive");
        }else{
            System.out.println("I'am dead");
        }

        SAVE_HOOK = null;
        System.gc();
        Thread.sleep(500);
        if (SAVE_HOOK != null){
            System.out.println("I'am still alive");
        }else{
            System.out.println("I'am dead");
        }
    }
}
```

运行结果如下  

```shell
finalize method executed!
I'am still alive
I'am dead
```

### 再谈引用  

无论是引用技术算法判断对象的引用数量，还是可达性分析算法判断对象是否可用引用链可达，判断对象是否存活都离不开"引用"。在java中有四种引用关系  

+ 强引用：是最传统的引用关系，即类似`Object obj = new Object()`这种引用关系。无论在任何情况下，只要强引用还存在，垃圾收集器永远都不会回收被引用的对象  

+ 软引用：是描述一些还有用、但不是必须的对象。只被软引用关联着的对象，在系统将要发生内存溢出时，会把这些对象列进回收范围之内进行第二次回收，如果这次回收还没有释放足够的内存，就会抛出"OutOfMemoryError"异常。使用方法：`SoftReference sf = new SoftReference<>(obj);`  

+ 弱引用：是比软引用还有弱的引用，只被弱引用关联的对象只能生存到下一次垃圾收集为止。当垃圾收集器开始工作，无论当前内存是否足够，都会回收只被弱引用关联的对象。使用方法`WeakReference sf = new WeakReference(obj);`  

+ 虚引用：它是最弱的一种引用关系。一个对象是否有虚引用完全不影响其生存时间，也无法通过一个虚引用来取得一个对象实例。为一个对象设置一个虚引用关联的唯一目的就是为了能够被垃圾回收时受到一个系统通知。使用方法```ReferenceQueue<Object> referenceQueue = new ReferenceQueue<>();
   PhantomReference sf = new PhantomReference<>(obj,referenceQueue);```

## 如何回收  

### 方法区的回收  

在《Java虚拟机规范》中提到过可以不要求虚拟机在方法区中实现垃圾回收，事实上也确实有未实现回收或者未能完整实现方法区类型卸载的收集器存在，方法去的垃圾回收的"性价比"通常也是比较低的  

方法区的垃圾回收主要涉及两部分内容：废弃的常量和不再使用的类型

#### 废弃的常量  

回收废弃的常量与回收java堆中的对象非常类似。假如一个字符串"java"曾经进入常量池 中，但是当前系统又没有任何一个字符串对象的值是"java"，换句话说，已经没有任何字符串对象引用 常量池中的"java"常量，且虚拟机中也没有其他地方引用这个字面量。如果在这时发生内存回收，而且 垃圾收集器判断确有必要的话，这个"java"常量就将会被系统清理出常量池。常量池中其他类（接口）、方法、字段的符号引用也与此类似   

#### 不再使用的类型  

判定一个类型是否属于"不再被使用"的条件就比较苛刻了，需要满足下面三个条件  

+  该类所有的对象全部被回收，也就说java堆该类的所有对象以及子类对象都被回收了  

+ 该类的类加载器已经被回收  

+ 该类的Class对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法  

即使满足上述三个条件，也只能说明"被允许回收"，而不是想对象一样没有了引用就必然会回收。HotSpot虚拟机提供了`-Xnoclassgc`参数控制是否进行类型回收  

### 垃圾回收算法  

#### 分代收集理论  

当前java虚拟机大多数都是遵循"分代收集"的理论进行设计的，它建立在两个假说之上  

+ 弱分代假说：绝大多数对象都是朝生夕死的  
+ 强分代假说：熬过越多次垃圾收集过程的对象越难以消亡
+ 跨代引用假说：跨代引用对于同代引用来说仅占极少数

把分代收集理论具体放到商用的虚拟机中，设计者一般会把堆空间分为新生代和老年代两个区域。在新生代中，每次垃圾收集都会有大批的对象死去而被回收，而每次回收后的对象被视为难以消亡的对象，逐步晋升到老年代中存放  

有一些名词需要解释一下  

+ 部分收集（Partial GC）：指目标不是完整收集整个java堆，其中又分为  

  + 新生代收集（Minor GC、Young GC）：指目标只是新生代的垃圾收集  

  + 老年代收集（Major GC、Old GC）：指目标只是老年代的垃圾收集。另外有些时候"Major GC"也会被指为整堆收集  

  + 混合回收（Mixed GC）：指目标是收集整个新生代以及部分老年代的垃圾回收，目前只要G1收集器会有这种行为

+ 整堆收集（Full GC）收集整个java堆和方法区的垃圾收集  

#### 标记清除算法  

标记清除算法是最基础的垃圾收集算法，分为"标记"和"清除"两个阶段：首先标记阶段就是标记出所有需要回收的对象，在标记完成后，清除阶段会清除这些已经被标记需要回收的对象；也可以反过来，标记不需要回收的对象，然后清除那些没有被标记的对象。标记就是利用之前的可达性分析算法，判断对象是否可以回收  

可以用下图来表示标记清除算法  

![标记清除算法](https://gitee.com/liujinxi931204/typoraImage/raw/master/img/%E6%A0%87%E8%AE%B0%E6%B8%85%E9%99%A4%E7%AE%97%E6%B3%95.jpg)  

  这个方法有两个缺点  

1. 执行效率不稳定。如果java中存在大量的对象，而这些对象大部分都是需要回收的。此时就必须进行大量的标记和清除动作，导致标记和清除两个过程的执行效率都随着对象数量的增长而降低  

2. 内存碎片化。在清除后会产生大量不连续的内存碎片，有可能导致程序在运行过程中无法给新的较大的对象找到足够的连续的内存而触发下一次的垃圾回收  

#### 标记复制算法  

为了解决标记清除算法导致内存碎片的问题，标记复制算法将内存按容量划分为大小相等的两块，每次只使用其中的一块。当一块使用完以后，就将还存活的对象全部复制到另一块内存，然后再把原来的内存一次全部清除掉。这样一来，新对象分配内存时，只需要移动堆顶的指针，按顺序分配即可。

可以用下图来表示标记复制算法  

![标记复制算法](https://gitee.com/liujinxi931204/typoraImage/raw/master/img/%E6%A0%87%E8%AE%B0%E5%A4%8D%E5%88%B6%E7%AE%97%E6%B3%95.jpg)  

这个方法有两个缺点  

1. 执行效率不稳定。如果有大量的对象都存活的时候，每次复制就需要花费大量的开销；但是对于少数对象存活的情况，复制的效率就会高很多  

2. 内存使用率不高。有一半的内存空间会被浪费掉  

HotSpot虚拟机的Serial、ParNew等新生代收集器均采用了一种优化的复制算法，将新生代分为一块较大的Eden空间和两块较小的Survivor空间，每次分配内存只使用Eden和其中一块Survivor。发生垃圾收集时，将Eden和Suvivor中任然存活的对象一次性复制到另一块Survivor空间上，然后直接清理掉Eden和已用过的那块Survivor空间。HotSpot虚拟机默认Eden和Survivor的大小比例是8:1，也就是每次新生代中可用空间为整个新生代容量的90%（Enden的80%和一个Survivor的10%），因此只有10%的空间被浪费了。

#### 标记整理算法  

标记复制算法在对象存活率比较高时，需要花费大量的开销用来执行复制操作。标记整理算法的第一个阶段也是进行标记操作，而第二个阶段则是让所有存活的对象移动到内存空间的一端，然后清理掉边界以外的内存。  

可以用下图来表示标记整理算法  

![标记整理算法](https://gitee.com/liujinxi931204/typoraImage/raw/master/img/%E6%A0%87%E8%AE%B0%E6%95%B4%E7%90%86%E7%AE%97%E6%B3%95.png)  

不过不论是否移动存活对象都会存在弊端，移动则回收过程更为复杂，不移动则内存分配时更为复杂。从垃圾收集的停顿时间来看，不移动对象停顿时间会更短，甚至可以不需要停顿，但是从整个程序的吞吐量来看，移动对象会更划算。

#### 分代的收集算法  

从上面三种算法可以知道，没有哪一种算法可以完美的解决垃圾回收的问题。在分代收集理论的基础上，就有了分代收集的算法。因为新生代的对象绝大多数都是朝生夕死的对象，那么使用标记复制算法更为合理，因为需要移动的对象数量较少。对于老年代，如果程序更关注停顿时间短，那么可以使用标记清除算法；如果程序更为关注吞吐量，使用标记整理算法更为合理。

