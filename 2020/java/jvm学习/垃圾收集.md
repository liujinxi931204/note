垃圾收回又称为GC（Garbage Collection），关于GC有三件事需要了解  

+ 哪些内存需要回收

+ 什么时候回收

+ 如何回收

## 哪些内存需要回收  

众所周知，java的内存区域分为五大部分：程序计数器、虚拟机栈、本地方法栈、堆和方法区。其中程序计数器、虚拟机栈和本地方法栈是线程私有的，跟随线程的创建而创建，随着线程销毁而销毁，因此这几个内存区域的分配和回收都是确定的，当方法或者线程结束的时候自然就会被回收了。而堆和方法区这两个区域有很显著的不确定性，这部分内存的分配和回收都是动态的，正是垃圾收集器需要关注的部分  

## 什么时候回收  

垃圾回收需要回收那些已经"死亡"的对象，也就是说这些对象不会再被使用了。如何判断一个对象不会再被使用呢？主要有两种方法：一种是引用计数算法，一种是可达性分析算法  

### 引用计数算法  

在对象中添加一个引用计数器，每当有一个地方引用它时，计时器的值就加一；当引用失效时，计数器的值减一；任何时刻计数器的值为零时，说明这个对象是不可再被使用的。此时这个对象可以作为垃圾被回收。

优点：原理简单，判断效率也很高

缺点：单纯的引用计数算法无法解决对象之间相互循环应用的问题  

![循环引用](https://gitee.com/liujinxi931204/typoraImage/raw/master/img/%E5%BE%AA%E7%8E%AF%E5%BC%95%E7%94%A8.png)  

### 可达性分析算法  

java语言使用的是可达性分析算法来判断对象是否存活的。这个算法的思路就是通过一系列称为"GC Roots"的根对象起点作为起始点集，从这些点开始，根据引用关系向下搜索，搜索过程所走过的路径称为"引用链"，如果某个对象到GC Roots间没有任何引用链相连，或者用图论的话来说从GC Roots到这个对象不可达，则证明此对象是不可能再被使用的  

  ![可达性分析算法](https://gitee.com/liujinxi931204/typoraImage/raw/master/img/%E5%8F%AF%E8%BE%BE%E6%80%A7%E5%88%86%E6%9E%90%E7%AE%97%E6%B3%95.png)

可达性分析算法可以解决相互引用的问题，如果从GC Roots不能到达这两个对象，那么即使这两个对象相互之间循环引用也是可以被判断为可以回收的对象的  

固定可以作为GC Roots的对象包括以下几种  

+ 在虚拟机栈中（栈帧中的本地变量表）中引用的对象，例如栈帧中的参数、局部变量、临时变量等  

+ 在方法区中类静态属性引用的对象，例如类中的引用类型静态变量  

+ 在方法区中常量引用的对象，例如字符串常量池里的引用  

+ 本地方法栈中引用的对象  

+ 虚拟机内部的引用，如基本数据类型对应的Class对象，一些常驻的异常对象（OutOfMemoryError），还有系统类加载器  

+ 所有被同步锁（synchornized关键字）持有的对象

+ 反映java虚拟机内部情况的JMX Bean、JVMTI中注册的回调、本地代码缓存等

除了这些固定的GC Roots之外，根据用户所选用的垃圾收集器以及当前垃圾回收的内存区域不同，还可以临时性的加入其他对象作为GC Roots，共同构成完整的GC Roots集合。

那么可达性分析算法判定为不可达的对象就真的一定会被回收吗？答案是否定的。要真正的宣告一个对象的死亡至少要经历两次标记的过程：如果对象在可达性分析后发现没有与GC Roots相连接，那么它将会第一次标记，随后进行一次筛选，筛选的条件是此对象是否有必要执行finalize()方法。假如对象没有覆盖finalize()方法，或者finalize()方法已经被虚拟机调用过，那么虚拟机将这两种情况都视为"没有必要执行"，此时虚拟机会判定对象已经死亡可以进行回收 

如果这个对象被判定为确有必要执行finalize()方法，那么该对象会被放置到一个名为F-Queue的队列之中，并在稍后由一条由虚拟机自动建立的、低调度优先级的Finalizer线程去执行它们的finalize方法。但是虚拟机不保证一定会等待finalize方法执行完毕，这是因为如果某个对象的finalize方法执行缓慢或者发生了死循环，将很可能导致F-Queue队列中的其他对象永久处于等待状态，甚至导致整个内存回收子系统的崩溃。finalize()方法是对象逃脱死亡命运的最后一次机会，稍后收集器将对F-Queue中的对象进行第二次小规模的标记，如果对象要在finalize()中成功拯救自己——只要重新与引用链上的任何一个对象建立关联即可，譬如把自己 （this关键字）赋值给某个类变量或者对象的成员变量，那在第二次标记时它将被移出“即将回收”的集 合；如果对象这时候还没有逃脱，那基本上它就真的要被回收了。

**对象的finalize()方法只会被JVM执行一次，如果进行二次GC再次触发了该对象回收就不会再执行了，直接会回收掉。并不鼓励使用finalize()方法，它运行代价高昂，不确定性大，无法保证各个对象的调用顺序**  

**从java9开始，finalize方法已经被标记为deprecated** 

下面有一个例子来演示对象的自我拯救  

```java
package test.vm;

public class FinalizeEscapeGC {
    public static FinalizeEscapeGC SAVE_HOOK;

    @Override
    protected void finalize() throws Throwable {
        super.finalize();
        System.out.println("finalize method executed!");
        FinalizeEscapeGC.SAVE_HOOK = this;
    }

    public static void main(String[] args) throws InterruptedException {
        SAVE_HOOK = new FinalizeEscapeGC();
        SAVE_HOOK = null;
        System.gc();

        //由于finalize方法执行优先级很低，所以需要暂停0.5秒等待它执行
        Thread.sleep(500);
        if (SAVE_HOOK != null){
            System.out.println("I'am still alive");
        }else{
            System.out.println("I'am dead");
        }

        SAVE_HOOK = null;
        System.gc();
        Thread.sleep(500);
        if (SAVE_HOOK != null){
            System.out.println("I'am still alive");
        }else{
            System.out.println("I'am dead");
        }
    }
}
```

运行结果如下  

```shell
finalize method executed!
I'am still alive
I'am dead
```

### 再谈引用  

无论是引用技术算法判断对象的引用数量，还是可达性分析算法判断对象是否可用引用链可达，判断对象是否存活都离不开"引用"。在java中有四种引用关系  

+ 强引用：是最传统的引用关系，即类似`Object obj = new Object()`这种引用关系。无论在任何情况下，只要强引用还存在，垃圾收集器永远都不会回收被引用的对象  

+ 软引用：是描述一些还有用、但不是必须的对象。只被软引用关联着的对象，在系统将要发生内存溢出时，会把这些对象列进回收范围之内进行第二次回收，如果这次回收还没有释放足够的内存，就会抛出"OutOfMemoryError"异常。使用方法：`SoftReference sf = new SoftReference<>(obj);`  

+ 弱引用：是比软引用还有弱的引用，只被弱引用关联的对象只能生存到下一次垃圾收集为止。当垃圾收集器开始工作，无论当前内存是否足够，都会回收只被弱引用关联的对象。使用方法`WeakReference sf = new WeakReference(obj);`  

+ 虚引用：它是最弱的一种引用关系。一个对象是否有虚引用完全不影响其生存时间，也无法通过一个虚引用来取得一个对象实例。为一个对象设置一个虚引用关联的唯一目的就是为了能够被垃圾回收时受到一个系统通知。使用方法```ReferenceQueue<Object> referenceQueue = new ReferenceQueue<>();
   PhantomReference sf = new PhantomReference<>(obj,referenceQueue);```

## 如何回收  

### 方法区的回收  

在《Java虚拟机规范》中提到过可以不要求虚拟机在方法区中实现垃圾回收，事实上也确实有未实现回收或者未能完整实现方法区类型卸载的收集器存在，方法去的垃圾回收的"性价比"通常也是比较低的  

方法区的垃圾回收主要涉及两部分内容：废弃的常量和不再使用的类型

#### 废弃的常量  

回收废弃的常量与回收java堆中的对象非常类似。假如一个字符串"java"曾经进入常量池 中，但是当前系统又没有任何一个字符串对象的值是"java"，换句话说，已经没有任何字符串对象引用 常量池中的"java"常量，且虚拟机中也没有其他地方引用这个字面量。如果在这时发生内存回收，而且 垃圾收集器判断确有必要的话，这个"java"常量就将会被系统清理出常量池。常量池中其他类（接口）、方法、字段的符号引用也与此类似   

#### 不再使用的类型  

判定一个类型是否属于"不再被使用"的条件就比较苛刻了，需要满足下面三个条件  

+  该类所有的对象全部被回收，也就说java堆该类的所有对象以及子类对象都被回收了  

+ 该类的类加载器已经被回收  

+ 该类的Class对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法  

即使满足上述三个条件，也只能说明"被允许回收"，而不是想对象一样没有了引用就必然会回收。HotSpot虚拟机提供了`-Xnoclassgc`参数控制是否进行类型回收  

### 垃圾回收算法  

#### 分代收集理论  

当前java虚拟机大多数都是遵循"分代收集"的理论进行设计的，它建立在两个假说之上  

+ 弱分代假说：绝大多数对象都是朝生夕死的  
+ 强分代假说：熬过越多次垃圾收集过程的对象越难以消亡
+ 跨代引用假说：跨代引用对于同代引用来说仅占极少数

把分代收集理论具体放到商用的虚拟机中，设计者一般会把堆空间分为新生代和老年代两个区域。在新生代中，每次垃圾收集都会有大批的对象死去而被回收，而每次回收后的对象被视为难以消亡的对象，逐步晋升到老年代中存放  

有一些名词需要解释一下  

+ 部分收集（Partial GC）：指目标不是完整收集整个java堆，其中又分为  

  + 新生代收集（Minor GC、Young GC）：指目标只是新生代的垃圾收集  

  + 老年代收集（Major GC、Old GC）：指目标只是老年代的垃圾收集。另外有些时候"Major GC"也会被指为整堆收集  

  + 混合回收（Mixed GC）：指目标是收集整个新生代以及部分老年代的垃圾回收，目前只要G1收集器会有这种行为

+ 整堆收集（Full GC）收集整个java堆和方法区的垃圾收集  

#### 标记清除算法  

标记清除算法是最基础的垃圾收集算法，分为"标记"和"清除"两个阶段：首先标记阶段就是标记出所有需要回收的对象，在标记完成后，清除阶段会清除这些已经被标记需要回收的对象；也可以反过来，标记不需要回收的对象，然后清除那些没有被标记的对象。标记就是利用之前的可达性分析算法，判断对象是否可以回收  

可以用下图来表示标记清除算法  

![标记清除算法](https://gitee.com/liujinxi931204/typoraImage/raw/master/img/%E6%A0%87%E8%AE%B0%E6%B8%85%E9%99%A4%E7%AE%97%E6%B3%95.jpg)  

  这个方法有两个缺点  

1. 执行效率不稳定。如果java中存在大量的对象，而这些对象大部分都是需要回收的。此时就必须进行大量的标记和清除动作，导致标记和清除两个过程的执行效率都随着对象数量的增长而降低  

2. 内存碎片化。在清除后会产生大量不连续的内存碎片，有可能导致程序在运行过程中无法给新的较大的对象找到足够的连续的内存而触发下一次的垃圾回收  

#### 标记复制算法  

为了解决标记清除算法导致内存碎片的问题，标记复制算法将内存按容量划分为大小相等的两块，每次只使用其中的一块。当一块使用完以后，就将还存活的对象全部复制到另一块内存，然后再把原来的内存一次全部清除掉。这样一来，新对象分配内存时，只需要移动堆顶的指针，按顺序分配即可。

可以用下图来表示标记复制算法  

![标记复制算法](https://gitee.com/liujinxi931204/typoraImage/raw/master/img/%E6%A0%87%E8%AE%B0%E5%A4%8D%E5%88%B6%E7%AE%97%E6%B3%95.jpg)  

这个方法有两个缺点  

1. 执行效率不稳定。如果有大量的对象都存活的时候，每次复制就需要花费大量的开销；但是对于少数对象存活的情况，复制的效率就会高很多  

2. 内存使用率不高。有一半的内存空间会被浪费掉  

HotSpot虚拟机的Serial、ParNew等新生代收集器均采用了一种优化的复制算法，将新生代分为一块较大的Eden空间和两块较小的Survivor空间，每次分配内存只使用Eden和其中一块Survivor。发生垃圾收集时，将Eden和Suvivor中任然存活的对象一次性复制到另一块Survivor空间上，然后直接清理掉Eden和已用过的那块Survivor空间。HotSpot虚拟机默认Eden和Survivor的大小比例是8:1，也就是每次新生代中可用空间为整个新生代容量的90%（Enden的80%和一个Survivor的10%），因此只有10%的空间被浪费了。任何人都无法保证每次回收都只有不多于10%的对象存活，因此还有一个空间分配担保机制，当Survivor空间不足以容纳一次Minor GC之后存活的对象时，就需要依赖其他区域（一般是老年代）进行分配担保

![标记复制第一步](https://gitee.com/liujinxi931204/typoraImage/raw/master/img/%E6%A0%87%E8%AE%B0%E5%A4%8D%E5%88%B6%E7%AC%AC%E4%B8%80%E6%AD%A5.png)  

![标记复制第三步](https://gitee.com/liujinxi931204/typoraImage/raw/master/img/%E6%A0%87%E8%AE%B0%E5%A4%8D%E5%88%B6%E7%AC%AC%E4%B8%89%E6%AD%A5.png)  

#### 标记整理算法  

标记复制算法在对象存活率比较高时，需要花费大量的开销用来执行复制操作。标记整理算法的第一个阶段也是进行标记操作，而第二个阶段则是让所有存活的对象移动到内存空间的一端，然后清理掉边界以外的内存。  

可以用下图来表示标记整理算法  

![标记整理算法](https://gitee.com/liujinxi931204/typoraImage/raw/master/img/%E6%A0%87%E8%AE%B0%E6%95%B4%E7%90%86%E7%AE%97%E6%B3%95.png)  

不过不论是否移动存活对象都会存在弊端，移动则回收过程更为复杂，不移动则内存分配时更为复杂。从垃圾收集的停顿时间来看，不移动对象停顿时间会更短，甚至可以不需要停顿，但是从整个程序的吞吐量来看，移动对象会更划算。

#### 分代的收集算法  

从上面三种算法可以知道，没有哪一种算法可以完美的解决垃圾回收的问题。在分代收集理论的基础上，就有了分代收集的算法。因为新生代的对象绝大多数都是朝生夕死的对象，那么使用标记复制算法更为合理，因为需要移动的对象数量较少。对于老年代，如果程序更关注停顿时间短，那么可以使用标记清除算法；如果程序更为关注吞吐量，使用标记整理算法更为合理。

#### 算法细节  

##### STW  

在GC时所有的垃圾收集器都无法避免STW（Stop The World），即除JVM工作线程外，所有的用户线程都会被中断，程序全局暂停，其本质是通过挂起线程来阻断对JVM的操作

可达性分析算法中枚举根节点（GC Roots）会导致所有java用户线程停顿  

+ 分析工作必须在一个能确保一致性的快照中进行  

+ 一致性指整个分析期间执行系统看起来就像冻结在某个时间点上一样

+ 如果出现分析过程中对象引用关系还在发生变化，则分析结果的准确性就无法保证

调用`System.gc()`会导致STW的发生

##### 安全点  

程序在执行的时候并非在所有地方都能停下来开始GC，只有在特定的位置才可以停下来进行GC，这些位置被称为安全点。安全点的选择很重要，如果太少可能会导致STW的时间非常长，如果太频繁有可能会导致运行时的性能问题。通常会根据是否具有让程序长时间执行的特征为标准，比如选择一些执行时间长较长的指令作为安全点，如方法调用、循环跳转和异常跳转等  

如何在GC发生时，检查所有线程都跑到了最近的安全点停顿下来呢？  

+ 抢占式中断（目前已没有虚拟机采用）

  发生垃圾回收时，系统首先将所有用户线程全部中断，如果发现有用户线程中断的地方不在安全点上，就恢复这条线程的执行，让它一会再重新中断，直到跑到安全点上  

+ 主动式中断

  设置一个中断标志，各个线程在执行过程中会不停地主动去轮询这个标志，一旦发现中断标志为真时就自己在最近的安全点上主动挂起。轮询标志的地方和安全点是重合的

##### 安全区域  

当线程处于Sleep状态或者Blocked状态时，线程无法响应虚拟机的中断请求，不能再走到安全点主动将自己挂起，虚拟机显然也不可能持续等待线程重新被激活分配处理器时间。为了解决这个问题，引入了安全区域的概念。  

安全区域是指能够确保在某一段代码片段之中，引用关系不会发生变化，因此，在这个取域中任意地方开始垃圾收集都是安全的。也可以把安全区域看作是拉长的安全点  

当用户线程执行到安全区域里面的代码时，首先会标识自己已经进入了安全区域，那样当这段时间里虚拟机要发起垃圾收集时就不必去管这些已声明自己在安全区域内的线程了。当线程要离开安全区域时，它要检查虚拟机是否已经完成了根节点枚举（或者垃圾收集过程中其他需要暂停用户线程的阶段），如果完成了，那线程就当作没事发生过，继续执行；否则它就必须一直等待，直到收到可以离开安全区域的信号为止

##### 记忆集和卡表  

为了解决跨代引用所带来的问题，垃圾收集器在新生代中建立了名为记忆集（Remember Set）的数据结构，用以避免把整个老年代加入进GC Roots扫描范围。

记忆集是一种用于记录从非收集区域指向收集区域的指针集合的抽象数据结构，卡表则是这一抽象数据结构的一种具体实现，卡表中每个记录精确到一块内存区域，该区域内有对象含有跨代指针。在HotSpot虚拟机中，卡表只是一个字节数组，数组中的每一个元素代表一块内存区域，通常这个内存区域包含不止一个对象，只要这个内存区域中的一个或多个对象的字段存在着跨代指针，就将卡表对应的数组元素值标记为1，称为这个元素变脏；如果该内存区域中的对象的字段不存在跨代指针，对应的数组元素为0。在垃圾收集发生时，只要筛选出卡表中变脏的元素，就能轻易得出哪些内存区域包含跨代指针，把它们加入GC Roots中一并扫描  

![卡表与卡页](https://gitee.com/liujinxi931204/typoraImage/raw/master/img/%E5%8D%A1%E8%A1%A8%E4%B8%8E%E5%8D%A1%E9%A1%B5.png)  

##### 写屏障  

在有其他区域的对象引用了本区域的对象时，其对应的卡表元素就应该变脏，变脏的时间点原则上应该发生在引用类型字段赋值的那一刻。但问题是如何变脏，即如何在对象赋值的那一刻去更新卡表的元素。在HotSpot虚拟机中是通过写屏障（Write Barrier）技术维护卡表状态的。写屏障可以看作在虚拟机层面对"引用类型字段赋值"这个动作的AOP切 面，在引用对象赋值时会产生一个环形（Around）通知，供程序执行额外的动作，也就是说赋值的前后都在写屏障的覆盖范畴内。下面是一段更新卡表状态的简化逻辑  

```c++
void oop_field_store(oop* field, oop new_value) {
	// 引用字段赋值操作    
	*field = new_value;    
	// 写后屏障，在这里完成卡表状态更新    
	post_write_barrier(field, new_value); 
}
```

应用写屏障后，虚拟机就会为所有赋值操作生成相应的指令，一旦收集器在写屏障中增加了更新卡表操作，无论更新的是不是老年代对新生代对象的引用，每次只要对引用进行更新，就会产生额外的开销，不过这个开销与`Minor GC`时扫描整个老年代的代价相比还是低得多的。

#### 三色标记算法  

通过前面可以知道，在枚举GC Roots的时候会发生STW。那么如何解决或者降低用户线程的停顿，就会用到三色标记算法。目前主要采用三色标记算法的垃圾回收器有CMS和G1  

##### 前提  

+ 白色：表示对象尚未被垃圾收集器访问过。显然在可达性分析算法刚开始的时候所有的对象都是白色的。如果分析结束，对象还是白色的，说明这个对象是不可达的  

+ 黑色：表示对象已经被垃圾收集器访问过而且该对象所有的引用也已经被访问过。黑色的对象是安全存活的，如果有其他的引用指向了黑色，无需重新扫描一遍。黑色对象不可能不经过灰色对象直接指向一个白色的对象  

+ 灰色：表示对象已经被垃圾收集器访问过，而且至少有一个引用没有被访问过  

##### 过程  

三色标记的过程大概如下  

![三色标记算法](https://gitee.com/liujinxi931204/typoraImage/raw/master/img/%E4%B8%89%E8%89%B2%E6%A0%87%E8%AE%B0%E7%AE%97%E6%B3%95.png)  

##### 并行存在的问题  

枚举GC Roots的时候发生STW就是为了确保对象的引用关系不会发生变化。为了减少STW的时间，可以将用户线程和垃圾收集线程并行执行。但是这样就有可能发生两种情况：一种是将已经死亡的对象标记为存活，一种是将存活的对象标记为死亡。如果是发生前一种情况，只不过产生浮动垃圾，下一次的垃圾回收可以将其回收；第二种情况就是非常危险的，程序肯定会因此发生错误。

如下图所示

![三色标记算法存在的问题](https://gitee.com/liujinxi931204/typoraImage/raw/master/img/%E4%B8%89%E8%89%B2%E6%A0%87%E8%AE%B0%E7%AE%97%E6%B3%95%E5%AD%98%E5%9C%A8%E7%9A%84%E9%97%AE%E9%A2%98.png)  

##### 解决问题  

有两种解决方案来解决上述的问题：增量更新（Incremental Update）和原始快照（Snapshot At The Beginning，STAB）  

增量更新是指，当黑色对象插入新的指向白色对象的引用关系时，就将这个新插入的引用记录下来，等并发扫描结束之后，再将这些记录过的引用关系中的黑色对象为根，重新扫描一次。可以简单理解为，黑色对象一旦新插入了白色对象的引用之后，它就会变为灰色对象了。例如CMS垃圾收集器是基于增量更新来做并发标记的  

原始快照是指，当灰色对象要删除指向白色对象的引用关系时，就将这个要删除的引用记录下来，在并发扫描结束之后，再将这些记录过的引用关系中的灰色对象为根，重新扫描 一次。这也可以简化理解为，无论引用关系删除与否，都会按照刚刚开始扫描那一刻的对象图快照来进行搜索。例如G1垃圾收集器是基于原始快照来做并发标记的

## 垃圾收集器  

![垃圾收集器组合关系](https://gitee.com/liujinxi931204/typoraImage/raw/master/img/%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E7%BB%84%E5%90%88%E5%85%B3%E7%B3%BB.png)  

### 几个概念  

在垃圾收集过程中并发与并行的概念和在并发编程中的概念稍有不同  

+ 并行：并行描述的是多条垃圾收集线程之间的关系，说明同一时间有多条这样的线程在协同工作，通常默认此时用户线程处于等待状态  

+ 并发：并发描述的是垃圾收集器线程与用户线程之间的关系，说明同一时间垃圾收集器线程与用户线程都在执行。由于用户线程并未被冻结，所以程序仍然可以响应服务请求，但由于垃圾收集器线程占用了一部分系统资源，此时应用程序的吞吐量将会受到一定的影响

吞吐量  

吞吐量是指程序所花费的时间和系统总运行时间的比值，可以用下面的公式来表示
$$
吞吐量 = \frac{运行用户代码时间}{运行用户代码时间+运行垃圾收集时间}
$$

### 串行垃圾收集器  

从上面的图中可以知道新生代的串行垃圾收集器是Serial，老年代的串行垃圾收集器是Serial Old。这两个垃圾收集器也是在客户端模式下的默认垃圾收集器。串行不仅仅是只会使用一个处理器或者一条收集线程去完成垃圾收集，更重要的是在进行垃圾收集时，必须暂停其他所有工作线程，直到它收集结束。运行示意图如下  

![串行垃圾收集器](https://gitee.com/liujinxi931204/typoraImage/raw/master/img/%E4%B8%B2%E8%A1%8C%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8.png)  

对于单核处理器或者处理器核心较少的环境来说，串行垃圾收集器是一个很好的选择，因为没有额外的线程的开销，专心做垃圾收集  

### 并行垃圾收集器  

#### ParNew垃圾收集器  

ParNew垃圾收集实质上是Serial收集器的多线程版本，除了同时使用多条线程进行垃圾收集之外，其余的行为包括Serial收集器可用的所有控制参数、收集算法等都和Serial收集器完全一致。ParNew垃圾收集器的运行示意图如下  

![ParNew并行垃圾收集器](https://gitee.com/liujinxi931204/typoraImage/raw/master/img/ParNew%E5%B9%B6%E8%A1%8C%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8.png)  

从垃圾收集器的组合图也可以看到，从JDK 9开始，ParNew垃圾收集器只能和CMS垃圾收集器搭配使用。甚至在单线程的环境中，ParNew的效果绝对不会比Serial的效果好，原因就在于存在线程交互的开销  

#### Paralle垃圾收集器  

Parallel垃圾收集器是一款并行的垃圾收集器，新生代的Parallel垃圾收集器和老年代Parallel Old垃圾收集器搭配使用它的目标是达到一个可控制的吞吐量，因此也常被称为吞吐量优先的垃圾收集器。运行示意图如下所示  

![Parallel垃圾收集器](https://gitee.com/liujinxi931204/typoraImage/raw/master/img/Parallel%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8.png)  

Parallel垃圾收集器有两个参数用于精确控制吞吐量，分别是控制最大垃圾收集停顿时间的`-XX:MaxGCPauseMillis`和直接设置吞吐量大小的`-XX:GCTimeRatio`

+ `-XX:MaxGCPauseMillis`：参数允许设置一个大于0的毫秒数，收集器只能尽力保证内存回收花费的时间不超过用户设置的时间。但是设置的太小，就会导致每次垃圾收集只能回收很小一部分的内存，反而会更频繁的触发GC；如果设置的过大，那么吞吐量就会下降  

+ `-XX:GCTimeRatio`：参数应当是一个大于0小于100的整数，此时垃圾收集所占用的比率就是
$$
垃圾收集占用的比例=\frac{1}{1+GCTimeRatio}
$$

例如设置该参数为19，那么允许的最大垃圾收集时间就占总时间的5%（1/(1+19)）;如果设置此参数为99，那么允许的最大垃圾收集时间就占总时间的1%（1/(1+99)）

此外还有一个参数 `-XX:+UseAdaptiveSizePolicy`,这个参数被激活后，就不需要人工指定新生代的大小（`-Xmn`）、Eden和Survivor区域的比例（-XX：SurvivorRatio），晋升老年代对象的大小（-XX：PretenureSizeThreshold）等参数细节，虚拟机会根据当前系统的运行情况收集性能监控信息，动态调整这些参数已提供最合适的停顿时间或者最大的吞吐量，也被称为自适应策略。只需要把基本的内存数据设置好如堆的大小（`-Xmx`），然后使用`-XX:MaxGCPauseMillis`（更关注最大停顿时间）或者`-XX:GCTimeRatio`（更关注吞吐量）  

### CMS垃圾收集器  

CMS垃圾收集器是一种以获取最短回收停顿时间为目标的收集器。它的回收过程相比较之前的收集器更为复杂，整个过程分为以下四步：

1. 初始标记

2. 并发标记

3. 重新标记

4. 并发清除

在整个过程中，只有初始标记和重新标记两个阶段是STW的。初始标记阶段仅仅是标记一下GC Roots能直接管关联到的对象，速度很快；并发标记阶段是从GC Roots的直接关联对象开始遍历整个对象图的过程，这个过程耗时较长，但是不需要暂停用户线程，可以与垃圾回收线程一起并发运行；重新标记阶段是为了修正并发标记阶段，因用户线程运行导致标记发生变化的，这个阶段的停顿时间通常会比初始标记阶段稍长一些，但也远比并发标记的时间短；最后并发清除阶段，清理删除掉标记阶段判断已经死亡的对象，由于不需要移动存活对象，所以这个阶段也可以和用户线程同时并发  

![CMS垃圾收集器](https://gitee.com/liujinxi931204/typoraImage/raw/master/img/CMS%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8.png)  

CMS垃圾收集器存在以下明显的缺点  

1. CMS垃圾收集器对处理器资源非常敏感。默认启动的回收线程数是(处理器核心数量+3)/4。因此，如果处理器的核心数在4个或者以上，并发回收时垃圾收集线程只占用不到25%的处理器资源，并且会随着核心数的增加而下降；但是当处理器的核心数不足4个时，CMS对用户线程的影响就会比较大了  

2. 因为在并在标记阶段和并发清理阶段，垃圾收集线程是和用户线程并发运行的，因此这两个阶段用户线程也会产生垃圾，而标记阶段已经结束了，所以这些垃圾只能等待下一次的垃圾回收再清理，这些垃圾也被称为"浮动垃圾"。这样就要求CMS垃圾收集器预留一定的空间给并发运行的用户线程使用。这部分预留的空间由参数`-XX:CMSInitiatingOccupancyFraction`来控制，默认的阈值是92%。可以提高这个参数值，降低内存回收的频率。但是又会带来另一个问题，就是如果阈值设置的过高，导致新生代晋升老年代的对象没有足够的空间时，会导致并发失败（Concurrent Mode Failure），这时虚拟机需使用Serial Old垃圾收集，进行一次暂停所有用户线线程的垃圾收集  

3. 由于CMS基于标记清除算法，所以在收集结束时会产生内存碎片。当老年代内存碎片过多时，可能会出现老年代有很多剩余空间，但是无法找到足够的空间分配给当前对象，而不得不提前触发一次Full GC。因此CMS垃圾收集提供了`-XX:UseCMSCompactAtFullColletion`开关参数，默认开启，用于在CMS垃圾收集器不得不进行Full GC时开启内存碎片的合并整理工作。还有另一个参数`-XX:CMSFullGCsBeforeCompaction`，这个参数要求CMS进行若干次不整理空间的Full GC之后，下一次进入Full GC之前先进行内存碎片的整理，默认值是0  

### Garbage First垃圾收集器  

G1垃圾收集器是一款面向服务端的垃圾收集器，也是一款整堆的垃圾收集器。它在大多数情况下可以实现指定GC暂停时间，同时还能保持较高的吞吐量。这个垃圾收集器不要求每次都把垃圾清理干净，只是努力做它认为对的事。

之前介绍的垃圾收集器都是对某个年代的整体收集，G1则可以面向堆内存任何部分来组成回收集（Collection Set，简称CSet）进行回收，衡量标准不再是它属于哪个分代，而是哪块内存中存放的垃圾数量最多，回收收益最大。

虽然G1垃圾收集器仍然遵守分代收集理论，但是其内存布局还是和其他的垃圾收集器有着非常明显的差异：G1不再坚持固定大小以及固定数量的分代区域划分，而是把连续的堆划分为多个大小相等的独立区域（Region），每一个Region既可以是新生代的Eden区或者Survivor区，也可以是老年代。只不过在同一时刻，一个Region只能是Eden区或者Survivor区或者老年代。此外Region中还有一个专门存储大对象的区域叫做Humongous区域，当一个对象的大小超过了Region的一半，就认为这个对象是一个大对象，存放在Humongous区域中，而对于那些超过了整个Region大小的对象，则会存放在连续的几个Humongous区域中。G1的大多数行为将Humongous区域当作老年代来看待。

每个Region的大小可以通过参数`-XX:G1HeapRegionSize`来设置，范围为1MB~32MB，且应该为2的幂次。  

![G1垃圾收集器堆](https://gitee.com/liujinxi931204/typoraImage/raw/master/img/G1%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E5%A0%86.png)  

#### 收集集合  

一组可被回收的分区的集合。在收集集合（Collection Set，即CSet）中存活的数据会在GC过程中被移动到另一个可用分区，CSet中的分区可以来自Eden、Survivor或者老年代。CSet会占用不到整个堆空间的1%的大小  

#### 记忆集合  

记忆集合（Remember Set，即RSet）记录了Region的对象引用本Region中对象的关系，属于points-into（谁引用了我的对象）。RSet的价值在于使得垃圾收集不需要扫描整个堆找到谁引用了当前分区中的对象，只需要扫描RSet即可。之前说过一种卡表（Card Table）的记忆集的实现方式，那是一种points-out（我引用了谁的对象）。G1的RSet是在Card Table的基础上再加了一层结构i来构成points-into RSet：每个region会记录下到底哪些Region有指向自己的指针，而这些指针分别在哪些card的范围。这个RSet其实是一个hash table，key是比的Region的起始地址，value是一个集合，里面的元素是card table的index。举例来说，如果region A的RSet里有一项的key是region B，value里有index为1234的card，它的意思就是region B的一个card里有引用指向region A。所以对region A来说，该RSet记录的是points-into的关系；而card table仍然记录了points-out的关系。  

![G1记忆集](https://gitee.com/liujinxi931204/typoraImage/raw/master/img/G1%E8%AE%B0%E5%BF%86%E9%9B%86.png)  

对于年轻代的Region，它的Rset只保存了来自老年代的引用，因为年轻代的回收是针对所有年轻代的Region而言的，所以就没有必要保存来自年轻代的引用了。因此年轻代的RSet可以为空；老年代的RSet也只会保存来自老年代的引用，这是因为在老年代回收之前会进行一次年轻代的回收，这是Eden空间就为空了，而在回收过程中会扫描Survivor分区，所以也没有必要保存来自年轻代的引用。

#### 回收过程  

G1收集器的收集活动主要有四种操作  

+ 新生代的回收  

+ 后台收集、并发周期

+ 混合式垃圾收集

+ 必要的时候进行Full GC

##### 新生代的回收  

新生代的回收是一个STW的过程，当Eden区耗尽的时候会触发新生代收集，新生代垃圾收集会回收整个新生代。新生代回收存活的对象会被拷贝到Survivor区域或者Old区域  

![G1垃圾收集器的Young GC](https://gitee.com/liujinxi931204/typoraImage/raw/master/img/G1%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E7%9A%84Young%20GC.png)  

##### 并发标记阶段  

当整个堆内存使用达到一定的比例（默认是45%），并发标记阶段会被启动。这个比例是可以调整的，通过参数`-XX:InitiatingHeapOccupancyPercent`进行配置 

并发标记阶段是为混合式垃圾回收（Mixed GC）提供标记服务的。并不是一次GC过程中的必要阶段。这个过程和CMS的回收过程很类似，具体过程如下  

1. 初始标记

   这个过程共用了Young GC（Minor GC）的暂停，这是因为它们可以复用root scan操作。虽然是STW的，但是时间通常非常短  

2. 并发标记

   这个阶段从GC Roots开始对Heap中的对象标记，标记线程与用户线程并行执行，并且收集各个Region存活对象的信息。这个过程可以被Young GC中断。意味着并发标记的过程中可以穿插多次Young GC。  

3. 重新标记  

   和CMS类似，也是STW的。标记那些在并发标记阶段发生变化的对象  
   
4. 清理阶段  
   
   这个过程不需要STW。如果发现Region里全是垃圾，在这个阶段就会被清理掉。不全是垃圾的Region，并不会马上清理掉，而是在Mixed GC阶段进行收集  


![G1垃圾收集器并发标记过程](https://gitee.com/liujinxi931204/typoraImage/raw/master/img/G1%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E5%B9%B6%E5%8F%91%E6%A0%87%E8%AE%B0%E8%BF%87%E7%A8%8B.png)  

##### 混合回收  

混合回收（Mixed GC）不止会清理年轻代，也会清理一部分老年代。Mixed GC会执行多次，直到所有标记点老年代分区都被回收，在这之后就会恢复到常规的年轻代垃圾收集周期。在Mixed GC中，对于要回收的分区，会将该分区中存活的数据拷贝到另一个分区。

有一个参数`-XX:G1HeapWastePercent`：堆浪费百分比（默认值是5%）。在并发标记结束之后，就知道了老年代中有多少空间会要被回收。在每次Young GC之后和再次发生Mixed GC之前都会检查垃圾占比是否达到了此参数。如果垃圾占比超过了这个参数，就会发生Mixed GC，当G1发现可被回收的空间小于这个参数时，就不会再进行Mixed GC，也就是结束当前的混合收集周期。

![G1垃圾收集器Mixed GC](https://gitee.com/liujinxi931204/typoraImage/raw/master/img/G1%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8Mixed%20GC.png)  



