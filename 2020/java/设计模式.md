# 单例模式  
所谓类的单例模式，就是采取一定的方法保证在整个软件系统中，对某个类只能存在一个对象实例，并且该类只提供一个取得其对象实例的方法(通常是静态方法)  
单例模式共有八种实现方法：
1.饿汉式(静态常量)  
实现方法：  
1）构造器私有化(防止通过new来产生新的对象)  
2）类的内部创建对象  
3）向外暴露一个静态的公共方法getInstance  
```java
class Singleton{
    //1.构造器私有化，外部不能new
    private Singleton() {
    }
    //2.本类内部创建实例对象
    private final static Singleton instance = new Singleton();
    //3.提供一个共有的静态方法，返回实例对象
    public static Singleton getInstance(){
        return instance；
    }
}
```  
 
2.饿汉式(静态代码块)  
```java
class Singleton{
    //1.构造器私有化，外部不能new
    private Singleton() {
    }
    //2.本类内部创建实例对象
    static{
        instance = new Singleton();
    }
    //3.提供一个共有的静态方法，返回实例对象
    public static Singleton getInstance(){
        return instance；
    }
}
```  
饿汉式写法简单，就是在类装载的时候完成实例化，避免了线程同步的问题；但是在类装载的时候就完成实例化，也有可能从始至终该实例都没有被用到，这样就会造成内存的浪费。所以这种方法可用，但是又可能会造成内存的浪费  

3.懒汉式(线程不安全)  
```java
class Singleton {
    private static Singleton instance;
    private Singletone() {
    
    }
    //提供一个静态的方法，只有当使用到该方法的时候才会去创建instance
    public static Singleton getInstance() {
        if(instance == null){
            instance =new Singleton();
        } 
        return instance;
    }
}
```  
这种写法确实可以达到懒加载的效果，只有在需要的时候才会去创建对象，但是只能在单线程下使用，原因在于if语句。如果由多个线程进入if语句，就产生多个实例  

4.懒汉式(线程安全，同步方法)  
```java
class Singleton {
    private static Singleton instance;
    private Singletone() {
    
    }
    //提供一个静态的方法，只有当使用到该方法的时候才会去创建instance
    //加入synchronized关键字，解决线程安全问题  
    public static syncharonized Singleton getInstance() {
        if(instance == null){
            instance =new Singleton();
        } 
        return instance;
    }
}
```  
这个方法解决了线程安全的问题，但是效率低下，主要是每次执行getInstance方法的时候都要进行同步，实际上这个方法只执行一次实例化就够了，每面
5.懒汉式(线程安全，同步代码块)  
6.双重检查  
7.静态内部类  
8.枚举类  
