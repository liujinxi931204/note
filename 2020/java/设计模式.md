# 单例模式  
所谓类的单例模式，就是采取一定的方法保证在整个软件系统中，对某个类只能存在一个对象实例，并且该类只提供一个取得其对象实例的方法(通常是静态方法)  
单例模式共有八种实现方法：
1.饿汉式(静态常量)  
实现方法：  
1）构造器私有化(防止通过new来产生新的对象)  
2）类的内部创建对象  
3）向外暴露一个静态的公共方法getInstance  
```java
class Singleton{
    //1.构造器私有化，外部不能new
    private Singleton() {
    }
    //2.本类内部创建实例对象
    private final static Singleton instance = new Singleton();
    //3.提供一个共有的静态方法，返回实例对象
    public static Singleton getInstance(){
        return instance；
    }
}
```  
 
2.饿汉式(静态代码块)  
```java
class Singleton{
    //1.构造器私有化，外部不能new
    private Singleton() {
    }
    //2.本类内部创建实例对象
    static{
        instance = new Singleton();
    }
    //3.提供一个共有的静态方法，返回实例对象
    public static Singleton getInstance(){
        return instance；
    }
}
```  
饿汉式写法简单，就是在类装载的时候完成实例化，避免了线程同步的问题；但是在类装载的时候就完成实例化，也有可能从始至终该实例都没有被用到，这样就会造成内存的浪费。所以这种方法可用，但是又可能会造成内存的浪费  

3.懒汉式(线程不安全)  
```java
class Singleton {
    private static Singleton instance;
    private Singleton() {
    
    }
    //提供一个静态的方法，只有当使用到该方法的时候才会去创建instance
    public static Singleton getInstance() {
        if(instance == null){
            instance =new Singleton();
        } 
        return instance;
    }
}
```  
这种写法确实可以达到懒加载的效果，只有在需要的时候才会去创建对象，但是只能在单线程下使用，原因在于if语句。如果由多个线程进入if语句，就产生多个实例  

4.懒汉式(线程安全，同步方法)  
```java
class Singleton {
    private static Singleton instance;
    private Singleton() {
    
    }
    //提供一个静态的方法，只有当使用到该方法的时候才会去创建instance
    //加入synchronized关键字，解决线程安全问题  
    public static syncharonized Singleton getInstance() {
        if(instance == null){
            instance =new Singleton();
        } 
        return instance;
    }
}
```  
这个方法解决了线程安全的问题，但是效率低下，主要是每次执行getInstance方法的时候都要进行同步，实际上这个方法只执行一次实例化就够了，每面想要获得该实例，只需要return就可以了  

5.懒汉式(线程安全，同步代码块)  
6.双重检查  
```java
class Singleton {
    private static volatile Singleton instance;
    private Singleton() {
    
    }
    //提供一个静态的方法，只有当使用到该方法的时候才会去创建instance
    //加入双重检查代码，解决线程安全问题，同时解决懒加载问题，同时保证了效率
    public static Singleton getInstance() {
        if(instance == null){
            synchornized(Singletone.class){
                if( instance == null) {
                    instance =new Singleton();
                }
            }    
        } 
        return instance;
    }
}
```  
Doble-Check是在多线程开发中经常使用的，实例化代码只用执行一次，判断if(instance!=null),直接return实例化对象，避免反复进行方法同步，延迟加载，效率较高，推荐使用

7.静态内部类  

```java
class Singleton {
    private static volatile Singleton instance;
    private Singleton() {
    
    }
    //写一个静态内部类，该类有一个属性是instance
    //静态内部类的好处在于，外部类加载的时候，内部类不会加载
    //而调用getInstance的时候才会去加载静态内部类
    //避免了线程的不安全，利用静态内部类的特点实现延迟加载，效率高
    private static class SingletonInstance {
        private static final Singleton instance = new Singleton();
    }

    public static Singleton getInstance(){
        return SingletonInstance.instance;
    }
   
}
```  
8.枚举类  
```java
enum Singleton{  
    INSTANCE;
    public void method() {
    //方法体
    }
}
```  
借助JDK1.5中添加的枚举类来实现单例模式，不仅避免多线程的安全问题，而且还能防止反序列化重新创建新的对象，推荐使用  

